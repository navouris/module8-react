<!DOCTYPE html>
<html>
<head>
<title>module8-gr.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<div style = "border:5px solid lightgrey; padding:2rem" >
<div style="font-size:1.5rem; line-height:1.1; margin: auto;">
Πανεπιστήμιο Πατρών, HCI Master, Μάθημα: Front-end programming - Ενότητα 8
</div>
<br />
<br />
<br />
<div style="font-size:5rem; line-height:1.1; margin: auto;">
 Εισαγωγή στη React
</div>
<img src="https://upload.wikimedia.org/wikipedia/commons/a/a7/React-icon.svg">
<div style="font-size:2rem; line-height:2; margin: auto;">
Νίκος Αβούρης
</div>
<div style="font-size:2rem; line-height:3; margin: auto;">
Πάτρα - Απρίλιος 2021
</div>
</div>
<div style="page-break-after: always"></div>
<div style="page-break-after: always"></div>
<h1 id="%CE%B5%CE%B9%CF%83%CE%B1%CE%B3%CF%89%CE%B3%CE%AE-%CF%83%CF%84%CE%B7-react">Εισαγωγή στη React</h1>
<h3 id="%CE%BC%CE%AC%CE%B8%CE%B7%CE%BC%CE%B1-front-end-programming---%CE%B5%CE%BD%CF%8C%CF%84%CE%B7%CF%84%CE%B1-8">Μάθημα: Front-end programming - Ενότητα 8</h3>
<h2 id="81-%CF%80%CF%81%CE%BF%CE%BF%CE%AF%CE%BC%CE%B9%CE%BF">8.1 Προοίμιο</h2>
<ul>
<li>
<p>Η <strong>React</strong> (επίσης γνωστή ως React.js) είναι μια βιβλιοθήκη της JavaScript για τη δημιουργία διεπαφών χρήστη.</p>
</li>
<li>
<p>Συντηρείται από την εταιρία Facebook και μια κοινότητα προγραμματιστών και εταιρειών. Κυκλοφόρησε για πρώτη φορά το 2011 (Jordan Walke)</p>
</li>
<li>
<p>Η React μπορεί να χρησιμοποιηθεί ως βάση για την ανάπτυξη μιας ιστοσελίδας ή εφαρμογών για κινητά.</p>
</li>
<li>
<p>Η React αφορά μόνο την εμφάνιση δεδομένων στο DOM, και έτσι η δημιουργία εφαρμογών React απαιτεί συνήθως τη χρήση πρόσθετων βιβλιοθηκών για διαχείριση της κατάστασης (Redux) και τη δρομολόγηση μεταξύ σελίδων (React Router).</p>
</li>
<li>
<p>Η <strong>React Native</strong>, η οποία επιτρέπει την ανάπτυξη εγγενών εφαρμογών σε περιβάλλον Android, iOS και UWP (windows) με τη React, κυκλοφόρησε το 2015.</p>
</li>
<li>
<p>Η React είναι επί του παρόντος η πιο δημοφιλής βιβλιοθήκη/ πλαίσιο JS στην πλευρά του χρήστη, σύμφωνα με την <a href="https://insights.stackoverflow.com/survey/2020#technology">έρευνα τεχνολογίας προγραμματιστών stackoverflow</a>.</p>
</li>
</ul>
<div style="page-break-after: always"></div>
<h2 id="82-%CE%B5%CE%B9%CF%83%CE%B1%CE%B3%CF%89%CE%B3%CE%AE">8.2 Εισαγωγή</h2>
<ul>
<li>
<p>Ο σκοπός της React είναι η εμφάνιση περιεχομένου (HTML) στον χρήστη και ο χειρισμός της αλληλεπίδρασης των χρηστών.</p>
</li>
<li>
<p>Ο κώδικας εφαρμογής React αποτελείται από οντότητες που ονομάζονται <strong>στοιχεία (components)</strong>. Μεταβιβάζουμε δεδομένα στα στοιχεία, που ονομάζονται <strong>ιδιότητες- properties (props)</strong>.</p>
</li>
<li>
<p>Μπορούμε να δηλώσουμε στοιχεία μέσω συναρτήσεων ή κλάσεων.</p>
</li>
</ul>
<p><em>Δήλωση μέσω συνάρτησης του στοιχείου Greeting</em></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> Greeting = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello, {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
</div></code></pre>
<p><em>Δήλωση μέσω κλάσης του στοιχείου ParentComponent</em></p>
<pre class="hljs"><code><div><span class="hljs-comment">//class definition</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{ 
	state = { <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span> }; 
	render() { 
		<span class="hljs-keyword">return</span> ( 
			<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">color</span>=<span class="hljs-string">{this.state.color}</span> /&gt;</span></span> ); } } 
</div></code></pre>
<ul>
<li>
<p>Η React χρησιμοποιεί την <strong>JSX</strong> (JavaScript XML) για να εμφανίσει τα στοιχεία (η σύνταξη της JSX είναι παρόμοια με αυτή της HTML)</p>
</li>
<li>
<p>Η React επίσης επιτρέπει τον ορισμό <em>χειριστών συμβάντων (event handlers)</em></p>
</li>
<li>
<p>Χρησιμοποιούμε τις βιβλιοθήκες React και ReactDOM (για να χειριστούμε το DOM).</p>
</li>
</ul>
<div style="page-break-after: always"></div>
<h2 id="83-%CF%87%CF%81%CE%AE%CF%83%CE%B7-%CF%84%CE%B7%CF%82-react">8.3 Χρήση της React</h2>
<h3 id="%CE%BC%CE%B5-%CF%87%CF%81%CE%AE%CF%83%CE%B7-%CF%84%CE%BF%CF%85-%CE%B4%CE%B9%CE%B1%CE%B4%CE%B9%CE%BA%CF%84%CE%B9%CE%B1%CE%BA%CE%BF%CF%8D-%CF%80%CE%B5%CF%81%CE%B9%CE%B2%CE%AC%CE%BB%CE%BB%CE%BF%CE%BD%CF%84%CE%BF%CF%82-codesandbox">Με χρήση του διαδικτιακού περιβάλλοντος CodeSandbox</h3>
<ul>
<li>To <a href="https://codesandbox.io/">CodeSandbox</a> είναι ένα διαδικτυακό περιβάλλον που επιτρέπει την ανάπτυξη εφαρμογών με React.</li>
<li>Δημιουργούμε λογαριασμό χρήστη στο CodeSandbox με σύνδεση στο λογαριασμό μας στο github</li>
<li>Στη συνέχεια διαλέγουμε ένα</li>
</ul>
<h3 id="%CF%84%CE%BF%CF%80%CE%B9%CE%BA%CE%AE-%CE%B5%CE%B3%CE%BA%CE%B1%CF%84%CE%AC%CF%83%CF%84%CE%B1%CF%83%CE%B7-%CF%84%CE%B7%CF%82-react">Τοπική εγκατάσταση της React</h3>
<h4 id="1-%CE%B5%CE%B3%CE%BA%CE%B1%CF%84%CE%AC%CF%83%CF%84%CE%B1%CF%83%CE%B7-%CF%84%CE%BF%CF%85-node-js-%CE%B1%CE%BD-%CE%B4%CE%B5%CE%BD-%CE%AD%CF%87%CE%B5%CE%B9-%CE%AE%CE%B4%CE%B7-%CE%B5%CE%B3%CE%BA%CE%B1%CF%84%CE%B1%CF%83%CF%84%CE%B1%CE%B8%CE%B5%CE%AF">1. Εγκατάσταση του Node JS αν δεν έχει ήδη εγκατασταθεί</h4>
<ul>
<li>Ελέγξτε αν έχει ήδη εγκατασταθεί από γραμμή εντολών &gt; node --version</li>
<li>Αν ότι τότε προχωρήστε στην εγκατάστασή του από το <a href="https://nodejs.org/en/">nodejs.org</a></li>
</ul>
<h4 id="2-create-react-app">2. Create-react-app</h4>
<p>Εγκαθιστούμε στη συνέχεια το module <code>create-react-app</code> που επιτρέπει την αυτόματη δημιουργία του περιβάλλοντος μιας εφαρμογής React.</p>
<pre class="hljs"><code><div>npm install –g create-react-app
npx create-react-app myapp 
</div></code></pre>
<h4 id="%CF%83%CE%B7%CE%BC%CE%B5%CE%AF%CF%89%CF%83%CE%B7-%CE%B3%CE%B9%CE%B1-%CE%B1%CF%80%CE%B5%CE%B3%CE%BA%CE%B1%CF%84%CE%AC%CF%83%CF%84%CE%B1%CF%83%CE%B7">Σημείωση: για απεγκατάσταση</h4>
<pre class="hljs"><code><div>npm unistall –g create-react-app
rm –rf /usr/local/bin/create-react-app
</div></code></pre>
<h4 id="3-%CE%B5%CE%B3%CE%BA%CE%B1%CF%84%CE%AC%CF%83%CF%84%CE%B1%CF%83%CE%B7-%CE%BA%CE%B1%CE%B9-%CE%B4%CE%B7%CE%BC%CE%B9%CE%BF%CF%85%CF%81%CE%B3%CE%AF%CE%B1-%CE%BC%CE%B9%CE%B1%CF%82-%CE%BD%CE%AD%CE%B1%CF%82-%CE%B5%CF%86%CE%B1%CF%81%CE%BC%CE%BF%CE%B3%CE%AE%CF%82-react">3. Εγκατάσταση και δημιουργία μιας νέας εφαρμογής React</h4>
<pre class="hljs"><code><div>npx --ignore-existing create-react-app myapp 
………
Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts...
added 1810 packages from 770 contributors and audited 931495 packages in 165.644s
found 0 vulnerabilities
 
</div></code></pre>
<p><strong>Γιατί εγκαθίστανται τόσα πολλά εξαρτήματα ;</strong> Παρατηρούμε ότι εκτός από τις τρεις βασικές βιβλιοθήκες react, react-dom, και react-scripts εγκαθίστανται στη συνέχεια βιβλιοθήκες όπως η Babel, Webpack, και Dev Server.</p>
<p>Ποιος είναι ο ρόλος τους;</p>
<p>Η <a href="https://babeljs.io/">Babel</a> είναι ένας μεταγλωττιστής JavaScript compiler (<em>transpiler</em>) που χρησιμεύει για μετατροπή κώδικα ECMAScript 2015+ σε παλαιότερη έκδοση της JavaScript, η οποία μπορεί να διερμηνευτεί σε παλαιότερους φυλλομετρητές. The main things Babel can do are:</p>
<ul>
<li>Transforms syntax from ES2015+ to ES5 that is mostly used in users' browsers</li>
<li>Translates JSX to plain JavaScript</li>
</ul>
<p><a href="https://webpack.js.org/">Webpack</a> ένας στατικός συναθροιστής (static module bundler) εφαρμογών JavaScript. Όταν ο webpack επεξεργάζεται μια εφαρμογή, εσωτερικά παράγει ένα γράφο εξαρτήσεων που αντιστοιχεί κάθε module που απαιτεί το πρότζεκτ και δημιουργία ένα ενιαίο πακέτο.</p>
<img src="react1.png" width=400>
<h4 id="%CE%B4%CE%BF%CE%BC%CE%AE-%CE%B1%CF%81%CF%87%CE%B5%CE%AF%CF%89%CE%BD-%CE%B5%CE%BD%CF%8C%CF%82-%CF%80%CF%81%CF%8C%CF%84%CE%B6%CE%B5%CE%BA%CF%84-react">Δομή αρχείων ενός πρότζεκτ React</h4>
<pre class="hljs"><code><div>Project directory
    /src (source code folder)
      /components
        App.jsx
        componentA.jsx
        componentB.jsx
      index.js
      stylesheet.css
    /public (static files folder, images, etc.)
      index.html
      img1.png
    /node_modules (project dependencies)
    package.json (file for configuration of dependencies)
    package-lock.json (exact version of packages installed)
    Readme.md (instructions file)
</div></code></pre>
<h4 id="4-%CE%BC%CE%B5%CF%84%CE%AC-%CF%84%CE%B7%CE%BD-%CE%BF%CE%BB%CE%BF%CE%BA%CE%BB%CE%AE%CF%81%CF%89%CF%83%CE%B7-%CF%84%CE%B7%CF%82-%CE%B1%CE%BD%CE%AC%CF%80%CF%84%CF%85%CE%BE%CE%B7%CF%82-%CE%B3%CE%B9%CE%B1-%CE%BD%CE%B1-%CF%84%CF%81%CE%AD%CE%BE%CE%BF%CF%85%CE%BC%CE%B5-%CF%84%CE%B7%CE%BD-%CE%B5%CF%86%CE%B1%CF%81%CE%BC%CE%BF%CE%B3%CE%AE-myapp">4. Μετά την ολοκλήρωση της ανάπτυξης, για να τρέξουμε την εφαρμογή myapp</h4>
<pre class="hljs"><code><div>cd myapp
npm start
...
Compiled successfully!

You can now view myapp in the browser.

  Local:            http://localhost:3000/
  On Your Network:  http://192.168.1.4:3000/

Note that the development build is not optimized.
To create a production build, use npm run build.

</div></code></pre>
<div style="page-break-after: always"></div>
<h2 id="84-%CE%B7-%CF%80%CF%81%CF%8E%CF%84%CE%B7-%CE%BC%CE%B1%CF%82-%CE%B5%CF%86%CE%B1%CF%81%CE%BC%CE%BF%CE%B3%CE%AE-react">8.4 Η πρώτη μας εφαρμογή React</h2>
<h3 id="%CE%BC%CE%B5-%CF%87%CF%81%CE%AE%CF%83%CE%B7-%CF%84%CE%BF%CF%85-codesandbox">Με χρήση του <a href="https://codesandbox.io/">CodeSandbox</a></h3>
<ul>
<li>
<p>Δημιουργούμε ένα νέο sandbox χρησιμοποιώντας το React template, (react και react-dom είναι ήδη φορτωμένα στο τυπικό sandbox React)</p>
</li>
<li>
<p>στον φάκελο /public υπάρχει το αρχείο index.html, το οποίο διαμορφώνουμε ώστε να περιέχει το παρακάτω τμήμα body:</p>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../src/index.js"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</div></code></pre>
<ul>
<li>επίσης το αρχείο /src/index.js περιέχει τα παρακάτω:</li>
</ul>
<pre class="hljs"><code><div>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);
ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> καλή σας μέρα <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  rootElement
);
</div></code></pre>
<ul>
<li>
<p>Η μέθοδος <code>ReactDOM.render(component, target)</code> δέχεται ως πρώτο όρισμα ένα <em>στοιχείο HTML</em> που είναι γραμμένο σε <strong>JSX</strong> και ως δεύτερο όρισμα το <em>στοιχείο DOM στόχο</em>, συνήθως το μόνο στοιχείο html στο έγγραφο index.html.</p>
</li>
<li>
<p>Το <em>στοιχείο HTML</em> πρέπει να είναι ένα μόνο στοιχείο HTML, εάν θέλουμε να αποδώσουμε περισσότερα από ένα στοιχεία, θα πρέπει να τα περιλάβουμε σε ένα στοιχείο υποδοχέα, π.χ. ένα <code>&lt;div&gt;</code>.</p>
</li>
</ul>
<div style="page-break-after: always"></div>
<h2 id="85-%CE%B5%CE%B9%CF%83%CE%B1%CE%B3%CF%89%CE%B3%CE%AE-%CF%83%CF%84%CE%B7%CE%BD-jsx">8.5 Εισαγωγή στην JSX</h2>
<ul>
<li>Η <strong>JSX</strong> είναι μια διάλεκτος της JavaScript που επιτρέπει τη χρήση κώδικα που μοιάζει με HTML για τη δημιουργία διεπαφής χρήστη μέσω <em>στοιχείων React</em>. Ένα στοιχείο React περιέχει HTML για εμφάνιση στον χρήστη και <em>χειριστές</em> για χειρισμό ενεργειών του χρήστη στο στοιχείο.</li>
</ul>
<h3 id="%CE%B4%CE%B9%CE%B1%CF%86%CE%BF%CF%81%CE%AD%CF%82-%CF%84%CE%B7%CF%82-jsx-%CE%B1%CF%80%CF%8C-%CF%84%CE%B7%CE%BD-html">Διαφορές της JSX από την HTML</h3>
<h4 id="1-%CE%BC%CF%80%CE%BF%CF%81%CE%BF%CF%8D%CE%BC%CE%B5-%CE%BD%CE%B1-%CF%80%CE%B5%CF%81%CE%B9%CE%BB%CE%AC%CE%B2%CE%BF%CF%85%CE%BC%CE%B5-%CE%B5%CE%BA%CF%86%CF%81%CE%AC%CF%83%CE%B5%CE%B9%CF%82-javascript-%CE%BC%CE%AD%CF%83%CE%B1-%CF%83%CE%B5-%CE%BA%CF%8E%CE%B4%CE%B9%CE%BA%CE%B1-jsx-%CE%BC%CE%B5-%CF%87%CF%81%CE%AE%CF%83%CE%B7-jsvariable">1. Μπορούμε να περιλάβουμε εκφράσεις javascript μέσα σε κώδικα JSX με χρήση <code>{jsVariable}</code></h4>
<p><em>παράδειγμα:</em> Έστω ότι στον κώδικα του πρώτου παραδείγματος θέλουμε να ενσωματώσουμε την μεταβλητή <code>name</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> name = <span class="hljs-string">"Μαρία"</span>
<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);
ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> καλή σας μέρα αγαπητή {name} <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  rootElement
);
</div></code></pre>
<h4 id="2-%CE%B7-%CE%B5%CF%80%CE%B9%CE%B2%CE%BF%CE%BB%CE%AE-%CF%83%CF%84%CF%85%CE%BB-%CF%83%CF%84%CE%B1-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CE%B1-%CE%B3%CE%AF%CE%BD%CE%B5%CF%84%CE%B1%CE%B9-%CE%BC%CE%AD%CF%83%CF%89-%CE%B1%CE%BD%CF%84%CE%B9%CE%BA%CE%B5%CE%B9%CE%BC%CE%AD%CE%BD%CF%89%CE%BD-javascript-elem-value">2. Η επιβολή στυλ στα στοιχεία γίνεται μέσω αντικειμένων JavaScript <code>{elem: value}</code></h4>
<p><em>παράδειγμα:</em> τροποποιήστε τον κώδικα ώστε να επιβληθεί ένα στυλ που επιβάλει ένα μπλε πλαίσιο στο μήνυμά μας.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> name = <span class="hljs-string">"Μαρία"</span>
<span class="hljs-keyword">const</span> myStyle = {<span class="hljs-attr">border</span>:<span class="hljs-string">'2px solid blue'</span>}
<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);
ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{myStyle}</span>&gt;</span> καλή σας μέρα αγαπητή {name} <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  rootElement
);
</div></code></pre>
<h4 id="3-%CF%87%CF%81%CE%AE%CF%83%CE%B7-%CF%84%CE%BF%CF%85-%CE%B3%CE%BD%CF%89%CF%81%CE%AF%CF%83%CE%BC%CE%B1%CF%84%CE%BF%CF%82-classname-%CE%B1%CE%BD%CF%84%CE%AF-%CE%B3%CE%B9%CE%B1-class-%CF%83%CF%84%CE%B1-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CE%B1-html">3. Χρήση του γνωρίσματος <code>className</code> αντί για <code>class</code> στα στοιχεία HTML</h4>
<p>Αυτό γίνεται γιατί η λέξη <code>class</code> είναι δεσμευμένη λέξη της JavaScript (στη δήλωση κλάσεων).</p>
<p><em>παράδειγμα</em> αν στο αρχείο /public/index.html ορίσουμε το παρακάτω στυλ:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-selector-class">.h1class</span> {<span class="hljs-attribute">font-family</span>: sans-serif; <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid blue}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</div></code></pre>
<p>τότε μπορούμε να τροποποιήσουμε τον κώδικα JSX στο αρχείο src/index.js ως ακολούθως:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">const</span> name = <span class="hljs-string">"Μαρία"</span>;
<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);
ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"h1class"</span>&gt;</span> καλή σας μέρα αγαπητή {name} <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,
  rootElement
);
</div></code></pre>
<h4 id="4-%CF%87%CF%81%CE%AE%CF%83%CE%B7-%CF%84%CE%B7%CF%82-htmlfor-%CE%B1%CE%BD%CF%84%CE%AF-%CE%B3%CE%B9%CE%B1-for-%CF%89%CF%82-%CE%B3%CE%BD%CF%8E%CF%81%CE%B9%CF%83%CE%BC%CE%B1-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CF%89%CE%BD">4. Χρήση της <code>htmlFor</code> αντί για <code>for</code> ως γνώρισμα στοιχείων</h4>
<p>Επειδή η <code>for</code> είναι δεσμευμένη λέξη της JavaScript, δεν μπορούμε να την χρησιμοποιήσουμε ως γνώρισμα ενός στοιχείου JSX.</p>
<p>Για παράδειγμα ο παρακάτω κώδικας HTML:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"label"</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"name"</span>&gt;</span>        
</div></code></pre>
<p>σε JSX θα πρέπει να γραφτεί ως εξής:</p>
<pre class="hljs"><code><div>&lt;label className=<span class="hljs-string">"label"</span> htmlFor=<span class="hljs-string">"name"</span>&gt;
</div></code></pre>
<h4 id="5-%CF%8C%CE%BB%CE%B1-%CF%84%CE%B1-%CE%B3%CE%BD%CF%89%CF%81%CE%AF%CF%83%CE%BC%CE%B1%CF%84%CE%B1-html-%CE%B1%CE%BB%CE%BB%CE%AC%CE%B6%CE%BF%CF%85%CE%BD-%CF%83%CE%B5-camelcase-%CE%B3%CE%B9%CE%B1-%CE%BD%CE%B1-%CF%87%CF%81%CE%B7%CF%83%CE%B9%CE%BC%CE%BF%CF%80%CE%BF%CE%B9%CE%B7%CE%B8%CE%BF%CF%8D%CE%BD-%CF%89%CF%82-%CE%BC%CE%B5%CF%84%CE%B1%CE%B2%CE%BB%CE%B7%CF%84%CE%AD%CF%82-javascript">5. Όλα τα γνωρίσματα HTML αλλάζουν σε camelCase για να χρησιμοποιηθούν ως μεταβλητές javascript</h4>
<p>Τα <a href="https://www.w3schools.com/tags/ref_standardattributes.asp">γνωρίσματα HTML </a> περιλαμβάνουν τα: <code>contenteditable</code>, <code>spellcheck</code>, κλπ., αυτά αν χρησιμοποιηθούν στην JSX πρέπει να γίνουν camelCase, δλδ.<code>contentΕditable</code>, κλπ.
(συζήτηση για στυλ μεταβλητών, π.χ. camelCase, PascalCase, snake_case, kebab-case θα βρείτε στο <a href="https://betterprogramming.pub/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841">medium</a>)</p>
<h4 id="6-%CE%B7-jsx-%CE%B5%CE%AF%CE%BD%CE%B1%CE%B9-%CE%B1%CF%85%CF%83%CF%84%CE%B7%CF%81%CE%AE-%CF%8C%CF%80%CF%89%CF%82-%CE%BA%CE%B1%CE%B9-%CE%B7-xml-%CF%83%CF%84%CE%B1-%CE%B6%CE%B5%CF%85%CE%B3%CE%AC%CF%81%CE%B9%CE%B1-%CE%B5%CF%84%CE%B9%CE%BA%CE%B5%CF%84%CF%8E%CE%BD">6. Η JSX είναι αυστηρή (όπως και η XML) στα ζευγάρια ετικετών</h4>
<p><em>παράδειγμα</em> το παρακάτω δεν είναι αποδεκτά στην JSX:
<code>&lt;img src={img} &gt;</code>
η σωστή μορφή είναι:
<code>&lt;img src={img} /&gt;</code>
(ετικέτα που κλείνει)</p>
<h3 id="%CF%80%CE%B1%CF%81%CE%AC%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1-1-ex1">Παράδειγμα 1 (ex1)</h3>
<p>Η ιστοσελίδα <a href="https://picsum.photos/">picsum</a> επιτρέπει να κατεβάζουμε τυχαίες εικόνες διαστάσεων x μέσω του url: https://picsum.photos/x</p>
<p>Για παράδειγμα η διεύθυνση https://picsum.photos/200 θα επιστρέψει μια τυχαία σελίδα διαστάσεων 200x200 pixel.</p>
<p>Επίσης η https://picsum.photos/200?grayscale επιστρέφει μια τυχαία εικόνα διαστάσεων 200x200 σε αποχρώσεις του γκρι.</p>
<pre class="hljs"><code><div>Προσαρμόστε το παράδειγμα ώστε να δημιουργήσετε μια σελίδα με κεφαλίδα (h1) &quot;Η αγαπημένη μου εικόνα:&quot; που ακολουθείται από μια εικόνα 300x300 pixels
</div></code></pre>
<h3 id="%CE%BC%CE%AD%CF%81%CE%BF%CF%82-%CE%B2">Μέρος Β</h3>
<p>Η <code>new Date() </code> επιστρέφει την τρέχουσα ημερομηνία, και η μέθοδος <code>getHours()</code> του αντικειμένου Date επιστρέφει την ώρα της μέρας με τιμή από 0 στο 23. Συμπληρώστε την σελίδα ώστε να εμφανίζει το καλωσόρισμα &quot;Καλημέρα&quot; αν είναι από 0 μέχρι 12, &quot;Καλησπέρα&quot; αν είναι από 12 σε 18, &quot;Καλό βράδυ&quot; αν είναι από 18 σε 21, και &quot;Καληνύχτα&quot; αν είναι από 21 μέχρι 23.</p>
<img src="ex1-react.png" style="border: 1px solid bla">
<div style="page-break-after: always"></div>
<h2 id="86-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CE%B1-react">8.6 Στοιχεία React</h2>
<h3 id="%CF%84%CE%B1-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CE%B1components-react-%CE%BC%CF%80%CE%BF%CF%81%CE%BF%CF%8D%CE%BD-%CE%BD%CE%B1-%CE%B4%CE%B7%CE%BC%CE%B9%CE%BF%CF%85%CF%81%CE%B3%CE%B7%CE%B8%CE%BF%CF%8D%CE%BD-%CE%BC%CE%B5-%CF%83%CF%85%CE%BD%CE%B1%CF%81%CF%84%CE%AE%CF%83%CE%B5%CE%B9%CF%82-%CE%AE-%CE%BA%CE%BB%CE%AC%CF%83%CE%B5%CE%B9%CF%82">Τα στοιχεία(components) React μπορούν να δημιουργηθούν με συναρτήσεις ή κλάσεις.</h3>
<p>Η δημιουργία <strong>στοιχείων React</strong> μέσω κλάσεων δεν θεωρείται πλέον καλή πρακτική. Από την έκδοση React 16.8 με την εισαγωγή των hooks, τα απλούστερα συναρτησιακά στοιχεία μπορούν να χειριστούν την κατάσταση των στοιχείων, οπότε δεν απαιτείται πλέον η χρήση κλάσεων.</p>
<h4 id="%CF%80%CE%B1%CF%81%CE%AC%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1-%CE%B4%CE%B7%CE%BC%CE%B9%CE%BF%CF%85%CF%81%CE%B3%CE%AF%CE%B1-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CE%BF%CF%85-%CE%BC%CE%AD%CF%83%CF%89-%CF%83%CF%85%CE%BD%CE%AC%CF%81%CF%84%CE%B7%CF%83%CE%B7%CF%82">Παράδειγμα δημιουργία στοιχείου μέσω συνάρτησης</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// Δημιουργία στοιχείου React </span>
<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{   <span class="hljs-comment">// το όνομα σε Pascal case.</span>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Καλή σας μέρα! <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;};

<span class="hljs-comment">// Δείξε το στοιχείο στην οθόνη</span>
ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#root"</span>) );

</div></code></pre>
<p>Ένα στοιχείο είναι απλώς μια συνάρτηση που ασχεδιάζει τη διεπαφή χρήστη. Η σχεδίαση γίνεται όταν φορτώνεται η εφαρμογή για πρώτη φορά και όταν αλλάζουν οι τιμές των ιδιοτήτων (props) και της κατάστασης (state).</p>
<h3 id="%CE%B5%CE%BD%CF%83%CF%89%CE%BC%CE%AC%CF%84%CF%89%CF%83%CE%B7-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CF%89%CE%BD-react">Ενσωμάτωση στοιχείων React</h3>
<ul>
<li>
<p>Μπορούμε να ενσωματώσουμε στοιχεία React components μέσα σε άλλα στοιχεία.</p>
</li>
<li>
<p>Γενικά είναι καλή πρακτική να αφιερώνουμε ένα αρχείο .jsx για κάθε στοιχείο React.</p>
</li>
<li>
<p>Ο μηχανισμός ενσωμάτωσης στηρίζεται στην εξαγωγή (export) του στοιχείου στο αρχείο του ίδιου του στοιχείου και εισαγωγή του (import) στο αρχείο του πατρικού στοιχείου.</p>
</li>
<li>
<p>Στην εικόνα βλέπουμε την ενσωμάτωση των δύο στοιχείων <code>&lt;B /&gt;</code> και <code>&lt;C /&gt;</code> στο πατρικό στοιχείο <code>&lt;App /&gt;</code>.</p>
</li>
</ul>
<p><img src="react2.png" alt="component embeding"></p>
<div style="page-break-after: always"></div>
<h2 id="87-%CE%B9%CE%B4%CE%B9%CF%8C%CF%84%CE%B7%CF%84%CE%B5%CF%82-%CF%84%CF%89%CE%BD-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CF%89%CE%BD-react-props">8.7 Ιδιότητες των στοιχείων React (props)</h2>
<p>Μπορούμε να ορίσουμε τις ιδιότητες ενός στοιχείου React (props), ώστε να μπορούμε να περάσουμε τις τιμές αυτών των ιδιοτήτων κατά τη χρήση του στοιχείου, όπως για παράδειγμα, τις τιμές που λαμβάνουν τα χαρακτηριστικά ενός στοιχείου HTML.</p>
<p>Με αυτόν τον τρόπο μπορούμε να προσαρμόσουμε την εμφάνιση των στοιχείων, μέσω των δεδομένων που διαβιβάζονται σε αυτά, ως props.</p>
<p><em>Παράδειγμα:</em></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> Component = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>{
	<span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> { props.mame }<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);
	};
</div></code></pre>
<p>Μπορούμε να χρησιμοποιήσουμε το στοιχείο αυτό ως ακολούθως:</p>
<pre class="hljs"><code><div>&lt;Component name=<span class="hljs-string">"Καποδίστριας"</span> /&gt;
</div></code></pre>
<p>Σε αυτή την περίπτωση η τιμή που περνάει στο στοιχείο είναι όπως φαίνται παρακάτω ένα αντικείμενο:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">console</span>.log(props)
&gt;&gt; {<span class="hljs-attr">name</span>: <span class="hljs-string">"Καποδίστριας"</span>}
</div></code></pre>
<p>Φαίνεται επίσης ότι οι ιδιότητες ορίζονται  στα αντικείμενα με σύνταξη που θυμίζει τα γνωρίσματα των στοιχείων HTML.</p>
<h3 id="%CE%B7-%CF%80%CF%81%CF%8E%CF%84%CE%B7-%CE%BC%CE%B1%CF%82-%CE%B5%CF%86%CE%B1%CF%81%CE%BC%CE%BF%CE%B3%CE%AE-heroes21">Η πρώτη μας εφαρμογή: heroes21</h3>
<p>Η πρώτη εφαρμογή μας έχει στόχο την δημιουργία μιας ιστοσελίδας με τις προσωπικότητες της Ελληνικής επανάστασης του 1821.</p>
<p>Κατ' αρχάς συγκεντρώνουμε από διάφορες πηγές στοιχεία για κάποιες προσωπικοτήτες, Έλληνες και ξένους που έπαιξαν ρόλο στην επανάσταση. Τα συγκεντρώνουμε σε ένα αρχείο <code>heroes21.js</code> που έχει την εξής δομή:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> heroes21 = [
  {
    <span class="hljs-attr">id</span>: <span class="hljs-string">"1"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Θεόδωρος Κολοκοτρώνης"</span>,
    <span class="hljs-attr">imgURL</span>:
      <span class="hljs-string">"https://upload.wikimedia.org/wikipedia/commons/4/4b/Kolokotronis01.jpg"</span>,
    <span class="hljs-attr">life</span>: <span class="hljs-string">"Αρχιστράτηγος, οπλαρχηγός, Μεσσηνία, 1770 - Αθήνα, 1843"</span>
  },
  {
    <span class="hljs-attr">id</span>: <span class="hljs-string">"2"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Παλαιών Πατρών Γερμανός"</span>,
    <span class="hljs-attr">imgURL</span>:
      <span class="hljs-string">"https://upload.wikimedia.org/wikipedia/commons/4/48/Palaion_Patron_Germanos_1865_002.JPG"</span>,
    <span class="hljs-attr">life</span>: <span class="hljs-string">"Ιεράχης, φιλικός, Δημητσάνα Αρκαδίας, 1771 - Ναύπλιο, 1826 "</span>
  }]
</div></code></pre>
<p>Το αρχείο θα βρείτε στο υλικό του μαθήματος, όμως εσείς μπορείτε να το εμπλουτίσετε προσθέτωντας τις προσωπικότητες που θεωρείτε σημαντικές για την εξέγερση του 2021, φιλέλληνες, πολιτικούς, αγωνιστές, διανοούμενους, κ.λπ.)</p>
<p>Στόχος είναι να δημιουργήσουμε μια εφαρμογή όπως το ακόλουθο παράδειγμα:</p>
<img src="heroes21.png">
<p>Την εφαρμογή μπορείτε να δείτε σε λειτουργία στο netlify: <a href="https://csb-et05o.netlify.app/">heroes of 1821</a></p>
<p>Ξεκινάμε στο <a href="https://codesandbox.io">codesandbox.io</a> ένα καινούργιο project χρησιμοποιώντας το React template.</p>
<p>Στην εφαρμογή έχουν ήδη περιληφθεί τα εξής εξαρτήματα: react, react-dom και react-scripts.</p>
<p>Δομούμε την εφαρμογή ως εξής: έχουμε δύο φακέλους: <code>public</code> και <code>src</code>.</p>
<p>Στον πρώτο έχουμε το αρχείο <code>index.html</code>, το οποίο εκτός από τον τίτλο και σύνδεσμο στο αρχείο <code>index.js</code> που θα τοποθετήσουμε στο φάκελο <code>src</code> έχει μόνο ένα στοιχείο το <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>. Εδώ τελειώνει ουσιαστικά η HTML και αρχίζει η React.</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Μορφές του 1821<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"styles.css"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../src/index.js"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<p>Στον φάκελο <code>public</code> επίσης δημιουργούμε το αρχείο <code>styles.css</code>, όπου σταδιακά θα ορίσουμε την εμφάνιση των κλάσεων CSS που θα καθορίσουν την εμφάνιση των στοιχείων της διεπαφής. Για παράδειγμα της κλάσης <code>.heading</code> για την κεφαλίδα, της κλάσης <code>.card</code> για την κάρτα του ήρωα, την <code>.circle-img</code> για την εμφάνιση της εικόνας, κλπ.</p>
<p>Στον φάκελο <code>src</code> περιέχονται τα δεδομένα των ηρώων (αρχείο <code>heroes.js</code>), το αρχικό αρχείο της εφαρμογής React είναι το <code>index.js</code> που όπως είδαμε εισάγει το ριζικό στοιχείο React, το στοιχείο <code>&lt;App&gt;</code> και το εμφανίζει, μαζί του θα εμφανίσει όλη την ιεραρχία στοιχείων που θα χτίσουμε κάτω από το στοιχείο <code>&lt;App&gt;</code> :</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/App"</span>;

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#root"</span>));
</div></code></pre>
<p>Δημιουργούμε στη συνέχεια στον φάκελο <code>src</code> ένα φάκελο <code>components</code> στον οποίο θα τοποθετήσουμε όλα τα στοιχεία React που θα δημιουργήσουμε.</p>
<p>Το καθένα από αυτά τα στοιχεία περιέχεται σε ένα αρχείο <code>.jsx</code>:</p>
<img src="heroes21-components.png">
<p>Η ιεραρχία που ορίζουμε είναι ότι στο στοιχείο <code>&lt;App&gt;</code> περιέχονται στοιχεία <code>&lt;Card&gt;</code> ( η κάρτα ενός ήρωα), σε καθένα από τα οποία περιέχεται ένα στοιχείο <code>&lt;Detail&gt;</code> (το όνομα και το βιογραφικό του), και ένα στοιχείο <code>&lt;Portrait&gt;</code> (η φωτογραφία του).</p>
<p>Είναι φανερό ότι στο στοιχείο <code>&lt;App&gt;</code> θα πρέπει να ενσωματώσουμε πολλαπλά στοιχεία <code>&lt;Card&gt;</code> τόσα όσοι και οι ήρωες που περιέχονται στον πίνακα <code>heroes21</code>.</p>
<p>Είναι συνηθισμένη η χρήση συναρτησιακού προγραμματισμού στο σημείο αυτό, και ιδιαίτερα της συνάρτησης <code>map</code> η οποία εφαρμόζει το όρισμά της, που είναι μια συνάρτηση, σε ένα προς ένα τα στοιχεία του πίνακα και επιστρέφει ένα νέο πίνακα.</p>
<p>Το στοιχείο <code>&lt;App&gt;</code> συνεπώς ορίζεται ως εξής:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"heading"</span>&gt;</span>Μορφές του '21<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      {heroes21.map(createCard)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Η συνάρτηση <code>CreateCard</code> πρέπει για κάθε στοιχείο του πίνακα <code>heroes21</code> να επιστρέφει ένα στοιχείο τύπου <code>&lt;Card&gt;</code> στο οποίο να περνάμε ως props τα δεδομένα του αντίστοιχου ήρωα:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCard</span>(<span class="hljs-params">hero</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>
      <span class="hljs-attr">key</span>=<span class="hljs-string">{hero.id}</span>
      <span class="hljs-attr">name</span>=<span class="hljs-string">{hero.name}</span>
      <span class="hljs-attr">img</span>=<span class="hljs-string">{hero.imgURL}</span>
      <span class="hljs-attr">attr</span>=<span class="hljs-string">{hero.attr}</span>
      <span class="hljs-attr">life</span>=<span class="hljs-string">{hero.life}</span>
    /&gt;</span></span>
  );
}
</div></code></pre>
<p>Άρα στο σημείο αυτό της <App> θα έχουμε ένα πίνακα από στοιχεία <code>&lt;Card&gt;</code>:</p>
<p><code>[&lt;Card /&gt;, &lt;Card /&gt; ... &lt;Card /&gt;]</code></p>
<p>Σε κάθε περίπτωση που ορίζουμε ένα τέτοιο πίνακα στοιχείων React, είναι απαραίτητο καθένα από αυτά να έχει μια ιδιότητα <code>key</code> που να παίρνει μοναδική τιμή. Στην περίπτωσή μας χρησιμοποιήσαμε το γνώρισμα <code>hero.id</code> που είναι μοναδικό, αν δεν υπήρχε θα έπρεπε να δημιουργήσουμε εμείς ένα μοναδικό κλειδί για κάθε στοιχείο.</p>
<p>Πάμε στη συνέχεια να δούμε, πώς θα χρησιμοποιήσουμε τις ιδιότητες που έχουμε περάσει σε κάθε <code>&lt;Card&gt;</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Card</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"card"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"top"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"name"</span>&gt;</span>{props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Portrait</span> <span class="hljs-attr">img</span>=<span class="hljs-string">{props.img}</span> <span class="hljs-attr">attr</span>=<span class="hljs-string">{props.attr}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"bottom"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Detail</span> <span class="hljs-attr">detailInfo</span>=<span class="hljs-string">{props.life}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Όπως βλέπουμε το κάθε τέτοιο στοιχείο εμφανίζει το όνομα του ήρωα το οποίο υπάρχει στην ιδιότητα <code>name</code>:</p>
<pre class="hljs"><code><div>&lt;h2 className=<span class="hljs-string">"name"</span>&gt;{props.name}&lt;<span class="hljs-regexp">/h2&gt;
</span></div></code></pre>
<p>ενώ περνάει τις υπόλοιπες ιδιότητες στα στοιχεία <code>&lt;Portrait&gt;</code> και <code>&lt;Detail&gt;</code>. Αυτά τα στοιχεία είναι ιδιαίτερα απλά, αφού το μόνο που κάνουν είναι να δημιουργήσουν ένα στοιχείο HTML με τις πληροφορίες που πήραν από τις ιδιότητες props :</p>
<pre class="hljs"><code><div>export default function Detail(props) {
  return <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"info"</span>&gt;</span>{props.detailInfo}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>;
}
</div></code></pre>
<p>και το στοιχείο <code>&lt;Portrait&gt;</code>:</p>
<pre class="hljs"><code><div>export default function Portrait(props) {
  return <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"circle-img"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{props.img}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{props.attr}</span> 
    <span class="hljs-attr">title</span>=<span class="hljs-string">{props.attr}/</span>&gt;</span>;
} 
</div></code></pre>
<div style="page-break-after: always"></div>
<h2 id="88-%CF%84%CE%B1-hooks-%CE%BA%CE%B1%CE%B9-%CE%B7-%CE%B4%CE%B9%CE%B1%CF%87%CE%B5%CE%AF%CF%81%CE%B9%CF%83%CE%B7-%CE%BA%CE%B1%CF%84%CE%AC%CF%83%CF%84%CE%B1%CF%83%CE%B7%CF%82">8.8 Τα Hooks και η διαχείριση κατάστασης</h2>
<ul>
<li>
<p>Ως <strong>Κατάσταση (State)</strong> ορίζεται το σύνολο των δεδομένων της ιεραρχίας των στοιχείων React, που μπορούν να αλλάξουν κατά τη χρήση της εφαρμογής.</p>
</li>
<li>
<p>Σε μια εφαρμογή React, έχουμε δεδομένα σε δύο μορφές: ως <strong>ιδιότητες (props)</strong> που μεταβιβάζονται από στοιχείο σε στοιχείο της ιεραρχίας, όπως είδαμε στο παράδειγμα της προηγούμενης ενότητας, και ως <strong>κατάσταση (state)</strong> που είναι δεδομένα που συνήθως αποθηκεύονται σε ένα μέρος, πιο συχνά στη ρίζα του δέντρου.</p>
</li>
<li>
<p>Υπάρχει συσχέτιση μεταξύ δεδομένων <strong>κατάσταης (state)</strong> και <strong>ιδιοτήτων (props)</strong>: όταν αλλάζουν οι μεταβλητές κατάστασης, η αλλαγή επηρεάζει τις ιδιότητες που διαβιβάζονται στα στοιχεία της ιεραρχίας.</p>
</li>
<li>
<p>Επίσης οι ενέργειες του χρήστη ενδέχεται να αλλάξουν τα δεδομένα της κατάστασης και οι νέες αυτές τιμές πρέπει να σταλούν πίσω στην κορυφή του δέντρου, όπου αποθηκεύεται η κατάσταση, από τα στοιχεία στα οποία έγινε η αλληλεπίδραση με τον χρήστη.</p>
</li>
<li>
<p>Ακόμη σχετικά με την κατάσταση είναι τα δεδομένα που συλλέγονται από τον χρήστη από φόρμες, στις οποίες ο χρήστης εισάγει δεδομένα, ή αλλάζει την κατάστση στοιχείων φόρμας.</p>
</li>
<li>
<p>Υπάρχουν διάφοροι μηχανισμοί για διατήρηση της κατάστασης στην React. Στο παρελθόν κύρια χρησιμοποιούσαμε τα στοιχεία-αντικείμενα στα οποία η διατήρηση της κατάστασης ήταν εφικτή, ενώ στα στοιχεία-συναρτήσεις αυτό δεν ήταν δυνατόν. Με την έκδοση 16.8 (το 2018) όμως εισήχθη η δυνατότητα δημιουργίας <strong>hooks</strong> και μέσω αυτών είναι δυνατή η διαχείριση της κατάστασης σε στοιχεία-συναρτήσεις, όπως αυτά που έχουμε δει ως τώρα.</p>
</li>
<li>
<p>Ο μηχανισμός που χρησιμοποιείται για τη διατήρηση και την αλλαγή της κατάστασης, είναι <strong>hooks</strong>, ειδικότερα, το hook <code>useState()</code>. Υπάρχουν και άλλα hooks που μπορούν να χρησιμοποιηθούν για την προσθήκη λειτουργικότητας στα στοιχεία μας, όπως αποστολή / λήψη των δεδομένων κατάστασης στον εξυπηρετητή. Τα hooks που θα δούμε σε αυτά τα μαθήματα είναι τρία: το <code>useState()</code> για διαχείριση κατάστασης, το <code>useEffect()</code> για ορισμό παρενεργειών υπό συνθήκη, και το <code>useContext()</code> για δημιουργία ενός περιβάλλοντος μέσα στο οποίο μπορούμε να διαθέτουμε και να καταναλώνουμε δεδομένα. Εκτός από αυτά τα τρία, υπάρχουν και άλλα hooks, όπως το <code>useRef()</code> που θα αναφερθεί στη συνέχεια, τα οποία χρησιμοποιούνται λιγότερο, περισσότερες λεπτομέρειες <a href="https://reactjs.org/docs/hooks-intro.html">στα tutorial της React</a>.</p>
</li>
</ul>
<p>Θα πρέπει πριν προχωρήσουμε με το hook ορισμού μεταβλητών κατάστασης, να γίνει αναφορά σε μερικούς βασικούς κανόνες που ισχύουν για τα hooks.</p>
<ul>
<li>Τα hooks είναι συναρτήσεις της JavaScript με ιδιαίτερη χρήση.</li>
<li>Η κλήση των hooks μπορεί να γίνει μόνο μέσα από <strong>συναρτησιακά στοιχεία React</strong>.</li>
<li>Μπορούμε να καλέσουμε ένα hook μόνο στο υψηλότερο επίπεδο του στοιχείου, άρα δεν μπορούμε να καλέσουμε ένα hook μέσα σε βρόχους επανάληψης, σε δομές συνθήκης, ή σε ενσωματωμένες συναρτήσεις.</li>
</ul>
<h4 id="%CE%BF%CF%81%CE%B9%CF%83%CE%BC%CF%8C%CF%82-%CE%BC%CE%B5%CF%84%CE%B1%CE%B2%CE%BB%CE%B7%CF%84%CF%8E%CE%BD-%CE%BA%CE%B1%CF%84%CE%AC%CF%83%CF%84%CE%B1%CF%83%CE%B7%CF%82-state-variable">Ορισμός μεταβλητών κατάστασης (State variable)</h4>
<p>Έστω ότι επιθυμούμε να ορίσουμε μια μεταβλητή κατάστασης <code>starRating</code>, ή οποία είναι η μεταβλητή που ορίζει τη βαθμολογία ενός προϊόντος με ένα σύστημα από 0 έως 5 αστέρια. Η βαθμολογία αυτή μπορεί να αλλάξει για ένα προϊόν, ως αποτέλεσμα επιλογής του χρήστη. Ο ορισμός της ως μεταβλητής κατάστσης γίνεται ως εξής:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> [starRating, setStarRating] = useState(<span class="hljs-number">0</span>)
</div></code></pre>
<p>Ορίζουμε την μεταβλητή κατάστασης <code>starRating</code> καθώς και μια συνάρτηση μεταβολής της μεταβλητής κατάστασης <code>setStatRating()</code> οι οποίες ορίζονται με αποδόμηση του πίνακα που επιστρέφει η μέθοδος <code>useState(αρχική-τιμή)</code>. Στο παράδειγμά μας, η μεταβλητή <code>starRating</code> έχει ως αρχική τιμή = 0.</p>
<p>Όταν καλέσουμε τη συνάρτηση <code>setStatRating()</code> θα αλλάξει η τιμή της μεταβλητής κατάστασης, με βάση την τιμή που θα περάσουμε στο όρισμά της. Για παράδειγμα αν θέλουμε να αλλάξουμε την τιμή της μεταβλητής σε 5 :</p>
<pre class="hljs"><code><div>setStarRating(<span class="hljs-number">5</span>)
</div></code></pre>
<p>Ενώ αν θέλουμε να αυξήσουμε την τιμή της μεταβλητής κατάστασης κατά 1:</p>
<pre class="hljs"><code><div>setStarRating(starRating + <span class="hljs-number">1</span>)
</div></code></pre>
<p>Είναι συνηθισμένο στη συνάρτηση <code>setStatRating()</code> να περνάμε ως όρισμα μια άλλη συνάρτηση <code>f()</code>, η οποία να παίρνει ως όρισμα την προηγούμενη τιμή της μεταβλητής κατάστασης και να επιστρέφει τη νέα τιμή.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">prev</span>)</span>{
  <span class="hljs-comment">// υπολογισμός νέας τιμής</span>
  <span class="hljs-keyword">return</span> newStateValue;
}
</div></code></pre>
<p>In order to modify state at a place in the tree different than the node where state is maintained, we need to send down the tree a function that will be called when the state has changed.</p>
<h4 id="%CF%80%CE%B1%CF%81%CE%AC%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1-%CE%AD%CE%BD%CE%B1-%CF%83%CF%8D%CF%83%CF%84%CE%B7%CE%BC%CE%B1-%CE%B1%CE%BE%CE%B9%CE%BF%CE%BB%CF%8C%CE%B3%CE%B7%CF%83%CE%B7%CF%82-%CE%B5%CE%BD%CF%8C%CF%82-%CF%80%CF%81%CE%BF%CF%8A%CF%8C%CE%BD%CF%84%CE%BF%CF%82-%CE%BC%CE%B5-%CE%B1%CF%83%CF%84%CE%AD%CF%81%CE%B9%CE%B1">Παράδειγμα: ένα σύστημα αξιολόγησης ενός προϊόντος με αστέρια</h4>
<p>Στην ενότητα αυτή θα δούμε ένα παράδειγμα στο οποίο απαιτείται η διαχείριση μιας μεταβλητής κατάστασης.</p>
<p>Θα δημιουργήσουμε ένα στοιχείο React που μάς επιτρέπει να βαθμολογήσουμε ένα προϊόν με μια κλίμακα 5 αστέρων. Ο χρήστης θα επιλέγει ένα αστέρι και τα αντίστοιχα αστέρια μέχρι εκείνο που επέλεξε ο χρήστης, θα αλλάζουν σε κόκκινο από γκρι που είναι η αρχική τους κατάσταση, ενώ ένα σχετικό μήνυμα θα εμφανίζεται στο κάτω μέρος της εικόνας.</p>
<img src="starRating.png" width="250px">
<p>Τα αρχεία που θα δημιουργήσουμε στην εφαρμογή αυτή φαίνονται στη συνέχεια.</p>
<img src="starRating-files.png" width="200px">
<p>Το στοιχείο index.js είναι όπως και προηγουμένως:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/App"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"./styles.css"</span>

<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.querySelect(<span class="hljs-string">"#root"</span>);
ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span> /&gt;</span></span>,
  rootElement
);
</div></code></pre>
<p>Ενώ το αρχείο styles.css το εξής:</p>
<pre class="hljs"><code><div>.App {
  font-family: sans-serif;
  text-align: center;
  font-size: <span class="hljs-number">1.2</span>em;
  border: <span class="hljs-number">1</span>px solid bla;
}
</div></code></pre>
<p>Στον φάκελο components έχουμε τα εξής στοιχεία React:</p>
<p><strong>App.jsx</strong>
Το στοιχείο αυτό που είναι η ρίζα της ιεραρχίας των στοιχείων μας ορίζουμε τη μεταβλητή κατάστασης <code>starRating</code>, στην οποία θα αποθηκεύσουμε τη βαθμολογία του χρήστη, η μεταβλητή αρχικοποιείται στην τιμή 0.</p>
<p>Θα πρέπει να προσέξουμε ότι hooks όπως αυτό που δημιουργείται με κλήση της <code>useState()</code> επιτρέπεται να οριστούν μόνο μέσα σε στοιχεία React.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, {useState} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> Rating <span class="hljs-keyword">from</span> <span class="hljs-string">"./Rating"</span>

<span class="hljs-keyword">const</span> totalStars = <span class="hljs-number">5</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">prop</span>) </span>{

  <span class="hljs-keyword">const</span> [starRating, setStarRating] = useState(<span class="hljs-number">0</span>); <span class="hljs-comment">//μεταβλητή κατάστασης</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectStar</span>(<span class="hljs-params">id</span>)</span>{ <span class="hljs-comment">//συνάρτησης αλλαγής της μεταβλητής κατάστασης</span>
    <span class="hljs-keyword">if</span> (id&gt;=<span class="hljs-number">0</span> &amp;&amp; id &lt;= totalStars)setStarRating(id+<span class="hljs-number">1</span>)
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{prop.className}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Βαθμολογία<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Rating</span> 
        <span class="hljs-attr">stars</span> = <span class="hljs-string">{starRating}</span> 
        <span class="hljs-attr">totalStars</span> =<span class="hljs-string">{totalStars}</span> 
        <span class="hljs-attr">selectStar</span>=<span class="hljs-string">{selectStar}/</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Η τιμή της μεταβλητής κατάστασης μεταδίδεται προς τα κάτω στο δέντρο των στοιχείων React, ώστε να επιτρέπεται στα στοιχεία που εμφανίζουν τα αστέρια να τα εμφανίσουν ως κόκκινα ή γκρι, ανάλογα με την τιμή αυτής της μεταβλητής. Η κατάσταση μεταφέρεται προς τα κάτω μέσω της ιδιότητας <code>stars</code> που διαβιβάζεται στο στοιχείο <code>Rating</code>:</p>
<pre class="hljs"><code><div>stars = {starRating}
</div></code></pre>
<p>Στο στοιχείο <code>&lt;App&gt;</code> επίσης ορίζουμε τη συνάρτηση <code>selectStar()</code> η οποία θα πρέπει να κληθεί κάθε φορά που ο χρήστης επιλέγει ένα αστέρι, αυτή λαμβάνει ως όρισμα τον κωδικό του αστεριού που πατήθηκε από τον χρήστη (το id παίρνει τιμές από 0, έως 4) και τροποποιεί τη μεταβλητή κατάστασης με κλήση της συνάρτησης <code>setStarRating()</code>.</p>
<p>Αυτή η συνάρτηση όμως δεν χρησιμοποιείται στο στοιχείο <code>&lt;App&gt;</code>. Στο στοιχείο αυτό δεν υπάρχουν αστέρια, και ο χρήστης δεν μπορεί να τους αλλάξει την κατάσταση, τα αστέρια όπως θα δούμε στη συνέχεια σχεδιάζονται στο στοιχείο <code>&lt;Star&gt;</code>. Η συνάρτηση αυτή λοιπόν θα χρειαστεί πιο κάτω στην ιεραρχία των στοιχείων μας.</p>
<p>Ο τρόπος για να την διαθέσουμε στα στοιχεία που την χρειάζονται είναι να την περάσουμε ως ιδιότητα προς τα κάτω, ώστε να φτάσει τελικά στο στοιχείο  <code>&lt;Star&gt;</code> που βρίσκεται στο κάτω μέρος της ιεραρχίας, και εκεί θα κληθεί για να τροποιποιήσει την τιμή της μεταβλητής κατάστασης <code>starRating</code>.</p>
<p>Η μεταβίβαση της συνάρτησης αυτής ως ιδιότητας, γίνεται ως εξής (<em>προσοχή η πρώτη μεταβλητή είναι η ιδιότητα prop, ενώ η δεύτερη είναι η συνάρτηση που έχει το ίδιο όνομα</em> ):</p>
<pre class="hljs"><code><div>selectStar = {selectStar}
</div></code></pre>
<p>Τέλος το τρίτο στοιχείο που πρέπει να μεταφέρουμε προς τα κάτω είναι η τιμή της σταθεράς <code>totalStars</code> η οποία δηλώνει πόσα αστέρια πρέπει να σχεδιαστούν (υποθέτουμε ότι η κλίμακα είναι 5 αστέρων).</p>
<p><strong>Rating.jsx</strong></p>
<p>Το επόμενο στοιχείο της ιεραρχίας είναι το <code>&lt;Rating /&gt;</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> Star <span class="hljs-keyword">from</span> <span class="hljs-string">"./Star"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rating</span>(<span class="hljs-params">prop</span>)</span>{
  <span class="hljs-keyword">const</span> rating = prop.stars;
  <span class="hljs-keyword">const</span> totalStars = prop.totalStars;
  <span class="hljs-keyword">const</span> createArray = <span class="hljs-function"><span class="hljs-params">length</span> =&gt;</span> [...Array(length)];

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {createArray(totalStars).map((n, i) =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">Star</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{i}</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{i}</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">{rating</span> &gt;</span> i} clicked= {prop.selectStar} /&gt;
      ))}
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      {rating} of {totalStars} stars
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
}
</div></code></pre>
<p>Στο στοιχείο αυτό δημιουργούμε ένα πίνακα από αστέρια, μήκους <code>totalStars</code>. Το καθένα από τα στοιχεία αυτά είναι ένα <code>&lt;Star /&gt; </code>.</p>
<p>Ο τρόπος δημιουργίας του πίνακα, είναι με κλήση της συνάρτησης <code>createArray(length)</code> η οποία επιστρέφει ένα πίνακα μήκους <code>length</code> που περιέχει στοιχεία με τιμή undefined.</p>
<p><em>Σημείωση: αν χρησιμοποιούσαμε απλά τη δημιουργό <code>Array(totalStars)</code> θα παίρναμε πίσω ένα άδειο πίνακα, στον οποίο δεν θα μπορούσαμε να εφαρμόσουμε τη μέθοδο <code>map()</code></em></p>
<p>Στη συνέχεια με χρήση της <code>map()</code> δημιουργούμε τα στοιχεία <code>&lt;Star /&gt;</code>, στα οποία περνάμε ως ιδιότητες το <code>key</code> με τιμές από 0, έως 4, το <code>id</code> με τις ίδιες τιμές, το οποίο όμως το χρειαζόμαστε για να ελέγξουμε την ταυτότητα κάθε στοιχείου (το <code>key</code> είναι εσωτερική μεταβλητή που δεν μπορεί να κληθεί), η μεταβλητή <code>selected</code> που παίρνει την τιμή <code>true</code> για τα αστέρια που με βάση την τιμή της μεταβλητής <code>rating</code> πρέπει να χρωματιστούν κόκκινα, και τέλος περνάμε τη συνάρτηση μεταβολής κατάστασης την οποία κουβαλάμε από τον παραπάνω επίπεδο και την οποία εκχωρούμε στη μεταβλητή <code>clicked</code>.</p>
<p>Τέλος στο πιο κάτω επίπεδο της ιεραρχίας έχουμε τα στοιχεία <code>&lt;Star /&gt;</code> που συζητάμε στη συνέχεια.</p>
<p><strong>Star.jsx</strong></p>
<p>Το στοιχείο αυτό απλά σχεδιάζει ένα αστέρι. Έχει όμως ιδιαίτερο ενδιαφέρον γιατί εδώ θα κληθεί η συνάρτηση μεταβολής κατάστασης που κουβαλήσαμε υπομονετικά ως εδώ από τη ρίζα του δένδρου των στοιχείων μας. Πάμε να δούμε πώς.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> {FaStar} <span class="hljs-keyword">from</span> <span class="hljs-string">"react-icons/fa"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">prop</span>)</span>{
  <span class="hljs-keyword">const</span> starColor = (prop.selected) ? <span class="hljs-string">"red"</span> : <span class="hljs-string">"bla"</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickedStar</span>(<span class="hljs-params">e</span>)</span>{
    prop.clicked(prop.id);
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FaStar</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{fontSize:</span> "<span class="hljs-attr">3em</span>"}} <span class="hljs-attr">color</span>=<span class="hljs-string">{starColor}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{clickedStar}/</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Κατ' αρχάς για να σχεδιάσουμε το εικονίδιο του αστεριού χρησιμοποιούμε τη γρμματοσειρά που βρίσκουμε στη βιβλιοθήκη <a href="https://react-icons.github.io/react-icons/">'react-icons'</a>. Στη βιβλιοθήκη αυτή θα βρούμε πολλά χρήσιμα εικονίδια, μεταξύ άλλων στη βιβλιοθήκη στοιχείων <a href="https://react-icons.github.io/react-icons/icons?name=fa">Font Awesome</a> περιέχονται πάνω από 1500 εικονίδια για κάθε χρήση.</p>
<p>Μεταξύ τους το <code>&lt;FaStar /&gt;</code> που εισάγεται με την εντολή:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> {FaStar} <span class="hljs-keyword">from</span> <span class="hljs-string">"react-icons/fa"</span>;
</div></code></pre>
<p>Η εντολή αυτή βεβαίως προϋποθέτει ότι προηγούμενα έχουμε εισάγει τη σχετική βιβλιοθήκη στο περιβάλλον του πρότζεκτ μας (στο codesandbox αυτό είναι απλή επιλογή από το μενού Dependencies, στον υπολογιστή μας απλά με την εντολή <code>npm install react-icons</code>).</p>
<p>Το στοιχείο <code>&lt;FaStar /&gt;</code> είναι ένα στοιχείο το οποίο έχουμε εισάγει από μια εξωτερική βιβλιοθήκη. Είναι η πρώτη φορά που κάνουμε κάτι τέτοιο, όμως ένα από τα πιο σημαντικά πλεονεκτήματα της React είναι ακριβώς η δυνατότητα να εισάγουμε έτοιμα στοιχεία από εξωτερικές βιβλιοθήκες. Στην τελευταία ενότητα θα κάνουμε μια επισκόπηση από τέτοιες βιβλιοθήκες.
Το <code>&lt;FaStar /&gt;</code> είναι ένα στοιχείο στο οποίο μπορούμε να περάσουμε ιδιότητες όπως <code>style</code>, <code>color</code> αλλά και την ιδιότητα <code>onclick</code> η οποία θα πάρει ως τιμή μια συνάρτηση χειριστή-συμβάντων.</p>
<pre class="hljs"><code><div>onClick = {clickedStar}
</div></code></pre>
<p>Το ερώτημα είναι γιατί δεν χρησιμοποιήθηκε η συνάρτηση μεταβολής κατάστασης  που έχουμε κουβαλήσει ως εδώ από τη ρίζα του δένδρου στοιχείων;</p>
<p>Η απάντηση είναι ότι η συνάρτηση <code>clickedStar()</code> καλεί με τη σειρά της τη μέθοδο <code>prop.clicked()</code> που μεταβιβάστηκε σε αυτό το επίπεδο μέσω των στοιχείων, και η οποία αναφέρεται στη συνάρτηση <code>selectStar(id)</code> που ορίστηκε στη ρίζα <code>&lt;App /&gt;</code> και είναι αυτή που αλλάζει την μεταβλητή κατάστασης <code>starRating</code>.</p>
<p>Η ενδιάμεση αυτή κλήση της συνάρτησης μεταβολής κατάστασης έχει να κάνει με τα ορίσματα που παίρνουν οι χειριστές συμβάντων. Όπως γνωρίζουμε ένα χειριστής συμβάντων παίρνει ως όρισμα (προαιρετικά) ένα αντικείμενο τύπου event. Όμως εμείς θέλουμε να καλέσουμε τη συνάρτηση <code>selectStar(id)</code> που μεταφέραμε ως εδώ μέσω των props και να περάσουμε ως όρισμα την ταυτότητα του συγκεκριμένου αστεριού που έχει πατηθεί. Ανάλογα με την ιδιότητα του (από 0 μέχρι 4), θα αλλάξει η βαθμολογία του χρήστη. Ακριβώς αυτή τη λογική περιέχει η συνάρτηση <code>clickedStar()</code>.</p>
<p>Μόλις ο χρήστης πατήσει το αστέρι, καλείται η <code>clickedStar()</code> η οποία καλεί την <code>prop.clicked(prop.id)</code>, δηλαδή τη συνάρτηση <code>selectStar(id)</code> του στοιχείου <code>&lt;App /&gt;</code>, η οποία αλλάζει την τιμή της μεταβλητής κατάστασης <code>starRating</code>.</p>
<p>Το ενδιαφέρον είναι ότι η React κάθε φορά που αλλάζει η τιμή μιας ιδιότητας, ξανασχεδιάζει αυτόματα το αντίστοιχο στοιχείο, άρα μεταδίδεται η νέα τιμή προς τα κάτω στην ιεραρχία των στοιχείων, ενημερώνοντας τα στοιχεία, π.χ. αλλάζει το χρώμα των αστεριών που έχουν επιλέξει ο χρήστης.</p>
<p>Αυτός είναι ο μηχανισμός διαχείρισης της κατάστασης σε μια εφαρμογή React. Όπως θα δούμε στη συνέχεια υπάρχουν και άλλοι τρόποι για χειρισμό της κατάστασης χωρίς απαραίτητα να περνάμε τις τιμές και τις συναρτήσεις μεταβολής κατάστασης σε όλη την ιεραρχεία στοιχείων. Όμως η προσέγγιση που περιγράφτηκε σε αυτή την ενότητα είναι κατάλληλη για εφαρμογές με σχετικά λίγες μεταβλητές κατάστασης και λίγα στοιχεία.</p>
<div style="page-break-after: always"></div>
<h2 id="89-%CE%BF%CE%B9-%CF%86%CF%8C%CF%81%CE%BC%CE%B5%CF%82-%CF%83%CF%84%CE%B7-react">8.9 Οι φόρμες στη React</h2>
<p>Στην ενότητα αυτή θα δούμε πώς χειριζόμαστε φόρμες στην React, κάτι που απαιτεί ιδιαίτερη προσοχή.</p>
<p>Η React διαθέτει διαφορετικούς τρόπους για να χειριστούμε τα στοιχεία που εισάγουν οι χρήστες μέσω μιας φόρμας. Διακρίνουμε <strong>ελεγχόμενα</strong> και <strong>μη-ελεγχόμενα</strong> στοιχεία φόρμας, όπως περιγράφεται στη συνέχεια.</p>
<h4 id="%CE%BC%CE%B7-%CE%B5%CE%BB%CE%B5%CE%B3%CF%87%CF%8C%CE%BC%CE%B5%CE%BD%CE%B1-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CE%B1">Μη-ελεγχόμενα στοιχεία</h4>
<p>Ένας τρόπος είναι η άμεση πρόσβαση στα στοιχεία DOM μιας φόρμας, χρησιμοποιώντας το αντικείμενο <code>refs</code>.</p>
<p>Τα <strong>Refs</strong> είναι αντικείμενα που αποθηκεύουν τιμές για τα αντίστοιχα στοιχεία. Χρησιμοποιούνται μέσω του hook <code>useRef</code>.</p>
<p>Ας δούμε ένα παράδειγμα επιλογής χρώματος και ονόματος περιγραφής του χρώματος σε μια υποθετική εφαρμογή στην οποία ζητάμε από τους χρήστες να βαθμολογήσουν διάφορα χρώματα. Η φόρμα μας περιλαμβάνει δύο στοιχεία <code>&lt;input&gt;</code> και ένα <code>&lt;button&gt;</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ColorForm</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> txtTitle = useRef();
  <span class="hljs-keyword">const</span> hexColor = useRef();

  <span class="hljs-keyword">const</span> submit = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> { 
    e.preventDefault();
    <span class="hljs-keyword">const</span> title = txtTitle.current.value;
    <span class="hljs-keyword">const</span> color = hexColor.current.value;
    props.newColor(title, color);
    txtTitle.current.value = <span class="hljs-string">""</span>;
    hexColor.current.value = <span class="hljs-string">""</span>; }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{submit}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{txtTitle}</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"color name..."</span> <span class="hljs-attr">required</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{hexColor}</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color"</span> <span class="hljs-attr">required</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span> add <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>)
}
</div></code></pre>
<p>Σε αυτό το παράδειγμα, χρησιμοποιούμε το hook <code>useRef</code> για να κάνουμε αναφορά στα στοιχεία <code>&lt;input&gt;</code> του DOM και, στη συνέχεια, χρησιμοποιώντας την <code>current.value</code> στέλνουμε τις εισαγόμενες τιμές στη συνάρτηση <code>newColor()</code> που ορίζεται στο στοιχείο <code>&lt;App /&gt;</code>, στο οποίο συντηρείται η <em>κατάσταση</em> της εφαρμογής.</p>
<p>Πρέπει να δώσουμε ιδιαίτερη προσοχή στη χρήση της εντολής <code>e.preventDefault();</code> στον χειριστή του συμβάντος &quot;submit&quot;. H μέθοδος αυτή του αντικειμένου event αποτρέπει την τυπική συμπεριφορά, η οποία στην περίπτωση αυτή είναι η υποβολή της φόρμας και κατά συνέπεια η ανανέωση φορτώματος της σελίδας, κάτι που δεν επιθυμούμε να γίνει, αφού τα στοιχεία που υπέβαλε ο χρήστης θα τα χειριστεί η εφαρμογή React και όχι ο εξυπηρετητής.</p>
<h4 id="%CE%B5%CE%BB%CE%B5%CE%B3%CF%87%CF%8C%CE%BC%CE%B5%CE%BD%CE%B1-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CE%B1">Ελεγχόμενα στοιχεία</h4>
<p>Ένας δεύτερος τρόπος χειρισμού των δεδομένων που εισάγει ο χρήστης στη φόρμα είναι να ελέγχουμε τα στοιχεία <code>&lt;input&gt;</code> της φόρμας, απευθείας μέσω των στοιχείων της React και η συσχέτισή τους με την <em>κατάσταση</em> της εφαρμογής μας.</p>
<p>Αυτή η δεύτερη μέθοδος είναι και η προτεινόμενη.</p>
<p>Ας τροποποιήσουμε το προηγούμενο παράδειγμα της φόρμας, ακολουθώντας αυτή την προσέγγιση.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, {useState} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ColorForm</span>(<span class="hljs-params">props</span>) </span>{
<span class="hljs-comment">// props are: newColor </span>
  <span class="hljs-keyword">const</span> [color, setColor] = useState({<span class="hljs-attr">name</span>:<span class="hljs-string">""</span>, <span class="hljs-attr">hex</span>:<span class="hljs-string">""</span>})

  <span class="hljs-keyword">const</span> submit = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.preventDefault();
    props.newColor(color);
    setColor({<span class="hljs-attr">name</span>:<span class="hljs-string">""</span>, <span class="hljs-attr">hex</span>:<span class="hljs-string">""</span>});
  };

  <span class="hljs-keyword">const</span> handleName = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> { setColor(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> ({<span class="hljs-attr">name</span>: e.target.value, <span class="hljs-attr">hex</span>: prev.hex}))}
  
  <span class="hljs-keyword">const</span> handleHex = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> { setColor(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> ({<span class="hljs-attr">name</span>: prev.name, <span class="hljs-attr">hex</span>: e.target.value}))}

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{submit}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleName}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{color.name}</span>
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"color name..."</span> <span class="hljs-attr">required</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleHex}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{color.hex}</span> <span class="hljs-attr">required</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>ADD<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  );
}
</div></code></pre>
<ul>
<li>
<p>Σε αυτήν την περίπτωση χρησιμοποιούμε το hook <code>useState</code> για να διατηρούμε αρχείο των δύο μεταβλητών των <code>&lt;input&gt;</code>.</p>
</li>
<li>
<p>Όπως και στην προηγούμενη περίπτωση περνάμε μέσω τον ιδιοτήτων του στοιχείου τη συνάρτηση <code>newColor()</code> του στοιχείου <code> &lt;App /&gt;</code>, η οποία χειρίζεται τις νέες τιμές της φόρμας.</p>
</li>
<li>
<p>Σε αυτήν την περίπτωση του απ-ευθείας ελέγχου χρειαζόμαστε δύο χειριστές του συμβάντος <code>onChange</code> των στοιχείων <code>&lt;input /&gt;</code>, μέσω αυτών ενημερώνουμε τις μεταβλητές κατάστασης που εμφανίζονται στα στοιχεία αυτά.</p>
</li>
<li>
<p>Το αποτέλεσμα αυτής της προσέγγισης είναι ότι αυτά τα ελεγχόμενα στοιχεία της φόρμας επανασχεδιάζονται με κάθε πάτημα πλήκτρου χρήστη.</p>
</li>
</ul>
<div style="page-break-after: always"></div>
<h2 id="810-%CF%80%CE%B1%CF%81%CE%AC%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1-%CF%84%CE%B1-%CF%87%CF%81%CF%8E%CE%BC%CE%B1%CF%84%CE%AC-%CE%BC%CE%BF%CF%85">8.10 Παράδειγμα: 'τα χρώματά μου'</h2>
<p>Στην ενότητα αυτή θα περιγράψουμε μια νέα εφαρμογή που συνδυάζει όσα είπαμε στις προηγούμενες ενότητες για διαχείρισης της κατάστασης της εφαρμογής μας, με τη δυνατότητα ο χρήστης να εισάγει στοιχεία μέσω μιας φόρμας, καθώς και να αλλάξει την κατάσταση κάποιων στοιχείων, όπως το στοιχείο `<Rating /> που βαθμολογεί ένα προϊόν με κλίμαα από 0 μέχρι 5 αστέρια.
Μια τυπική εικόνα της εφαρμογής φαίνεται στη συνέχεια, ενώ μπορείτε επίσης να δείτε την εφαρμογή σε λειτουργία στο <a href="https://csb-xf23j.netlify.app/">netlify</a>.</p>
<img src="colors-form.png" width="250">
<p>Στην εικόνα φαίνεται μια φόρμα με δύο στοιχεία εισόδου ένα είναι επιλογή χρώματος και το δεύτερο είναι η εισαγωγή του ονόματος του χρώματος.</p>
<p>Από κάτω φαίνονται σε ξεχωριστές καρτέλες, χρώματα που έχουν ήδη εισαχθεί.</p>
<p>Η αρχιτεκτονική αυτής της εφαρμογής φαίνεται στην παρακάτω εικόνα:</p>
<img src="colors-comp.png">
<p>Το ριζικό στοιχείο της εφαρμογής φαίνεται στη συνέχεια.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">"../styles.css"</span>;
<span class="hljs-keyword">import</span> React, {useState} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> colorData <span class="hljs-keyword">from</span> <span class="hljs-string">"../colors.json"</span>;
<span class="hljs-keyword">import</span> ColorList <span class="hljs-keyword">from</span> <span class="hljs-string">"./ColorList"</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">const</span> [colors, setColors] = useState(colorData);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newColor</span>(<span class="hljs-params">newColor</span>)</span>{
    <span class="hljs-comment">// δημιουργία νέου χρώματος</span>
    ...
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeColor</span>(<span class="hljs-params">id</span>)</span>{
    <span class="hljs-comment">// κατάργηση του χρώματος με ταυτότητα id</span>
    ...
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rateColor</span>(<span class="hljs-params">id, star, totalStars</span>)</span>{
    <span class="hljs-comment">// αλλαγή βαθμολογίας χρώματος με ταυτότητα id</span>
    ...
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ColorList</span> 
        <span class="hljs-attr">colors</span> = <span class="hljs-string">{colors}</span> 
        <span class="hljs-attr">newColor</span> = <span class="hljs-string">{newColor}</span> 
        <span class="hljs-attr">removeColor</span> = <span class="hljs-string">{removeColor}</span>
        <span class="hljs-attr">rateColor</span> = <span class="hljs-string">{rateColor}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Στο στοιχείο αυτό συντηρείται η <em>μεταβλητή κατάστασης</em> <code>colors</code>. Η οποία σε αντίθεση με προηγούμενο παράδειγμα, είναι σύνθετη μεταβλητή αφού περιέχει ένα πίνακα από αντικείμενα.</p>
<p>Το καθένα από τα αντικείμενα αυτά περιλαμβάνει τα στοιχεία ενός χρώματος, ταυτότητα αντικειμένου, περιγραφή, δεκαεξαδική χρωματική κωδικοποίηση, βαθμολογία σε κλίμακα 5-αστέρων,  πχ.</p>
<pre class="hljs"><code><div>{
    <span class="hljs-string">"id"</span>: <span class="hljs-string">"0"</span>,
    <span class="hljs-string">"title"</span>: <span class="hljs-string">"θαλασσί"</span>,
    <span class="hljs-string">"color"</span>: <span class="hljs-string">"#00c4e2"</span>,
    <span class="hljs-string">"rating"</span>: <span class="hljs-number">5</span>
  }
</div></code></pre>
<p>Ορίζουμε τρεις συναρτήσεις οι οποίες διαχειρίζονται τα χρώματα, τη συνάρτηση <code>newColor(newColor)</code> που δημιουργεί ένα νέο χρώμα με κλήση της setColors(), τη συνάρτηση <code>removeColor(id)</code> η οποία καταργεί το χρώμα με ταυτότητα id:</p>
<pre class="hljs"><code><div>setColors(<span class="hljs-function">(<span class="hljs-params">prev</span>)=&gt;</span>{ <span class="hljs-keyword">return</span> prev.filter(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>item.id !== id) })
</div></code></pre>
<p>τέλος την <code>rateColor(id, star, totalStars)</code> η οποία τροποποιεί την ιδιότητα <code>rating</code> στο χρώμα με ταυτότητα <code>id</code>;</p>
<pre class="hljs"><code><div>setColors (<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> prev.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (item.id === id){
      <span class="hljs-keyword">return</span> {...item, <span class="hljs-string">'rating'</span>: star+<span class="hljs-number">1</span>}
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> item;
  })
})
</div></code></pre>
<p>Το στοιχείο <code>&lt;App /&gt;</code> περιέχει μόνο το στοιχείο <code>&lt;ColorList /&gt;</code> στο οποίο περνάμε όλα τα χρώματα, καθώς και τις τρεις αυτές συναρτήσεις διαχείρισής τους.</p>
<p>Το στοιχείο <code>&lt;ColorList /&gt;</code> έχει το εξής περιεχόμενο:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ColorList</span>(<span class="hljs-params">props</span>)</span>{

  <span class="hljs-keyword">const</span> [showF, setShowF] = useState(<span class="hljs-literal">false</span>)

  <span class="hljs-keyword">const</span> theColors = props.colors.map(
    <span class="hljs-function">(<span class="hljs-params">color</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Color</span> 
        <span class="hljs-attr">key</span>=<span class="hljs-string">{color.id}</span> 
        <span class="hljs-attr">removeColor</span> = <span class="hljs-string">{props.removeColor}</span> 
        <span class="hljs-attr">rateColor</span> = <span class="hljs-string">{props.rateColor}</span> 
        {<span class="hljs-attr">...color</span>}  /&gt;</span></span>
    }
  )

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">e</span>)</span>{
    setShowF(<span class="hljs-literal">true</span>);
  }
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span> = <span class="hljs-string">"App"</span>&gt;</span> Τα αγαπημένα χρώματά μου <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">title</span>=<span class="hljs-string">" νέο χρώμα ..."</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handler}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">FaPlusCircle</span> <span class="hljs-attr">className</span> = <span class="hljs-string">"newColor"</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      {showF &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">ColorForm</span> <span class="hljs-attr">newColor</span>=<span class="hljs-string">{props.newColor}/</span>&gt;</span>}
      { theColors}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}

</div></code></pre>
<p>Το στοιχείο αυτό περιέχει τα περισσότερα στοιχεία της σελίδας μας, το τίτλο, το στοιχείο που αναπαριστά το ( + ) για ενεργοποίηση της φόρμας εισαγωγής νέου χρώματος, το οποίο όταν πατηθεί καλείται η συνάρτηση <code>handler()</code> η οποία ενεργοποιεί την τοπική μεταβλητή κατάστασης <code>showF</code> που έχει ως συνέπεια να ενεργοποιείται το στοιχείο <code>&lt;ColorForm /&gt;</code> και τέλος ενεργοποιείται η ακολουθία από στοιχεία <code>&lt;Color /&gt;</code>, ένα για καθένα από τα χρώματα που υπάρχουν στην μεταβλητή κατάστασης <code>colors</code>.</p>
<p>Καθένα από τα στοιχεία <code>&lt;Color /&gt;</code> παρουσιάζουν τα δεδομένα τίτλου και χρωματικού κωδικού του χρώματος, ένα στοιχείο (το <code>&lt;FaTrashAlt /&gt;</code>) που αναπαριστά ένα καλάθι απορριμάτων, που όταν πατηθεί καλείται αντίστοιχα η συνάρτηση <code>removeColor(id)</code> και τέλος περιέχεται το στοιχείο <code>&lt;StarRating /&gt;</code> που περιγράφτηκε στην προηγούμενη ενότητα.</p>
<p>Το στοιχείο που έχει περισσότερο ενδιαφέρον εδώ είναι το <code>&lt;ColorForm /&gt;</code>, το οποίο είναι μια φόρμα ορισμού νέου χρώματος που περιέχει ελεγχόμενα στοιχεία <code>&lt;input &gt;</code>.</p>
<p>Το περιεχόμενο του είναι:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ColorForm</span>(<span class="hljs-params">props</span>) </span>{
<span class="hljs-comment">// οι ιδιότητες είνα: newColor function to insert </span>
  <span class="hljs-keyword">const</span> [newItem, setNewItem] = useState({<span class="hljs-attr">title</span>:<span class="hljs-string">""</span>, <span class="hljs-attr">color</span>:<span class="hljs-string">""</span>})
  
  <span class="hljs-keyword">const</span> submit = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.preventDefault();
    <span class="hljs-built_in">console</span>.log(newItem);
    <span class="hljs-keyword">if</span> (newItem.title !== <span class="hljs-string">""</span> &amp;&amp; newItem.color !== <span class="hljs-string">""</span>) 
            props.newColor(newItem);}
  };

  <span class="hljs-keyword">const</span> handleName = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> { 
    setNewItem( <span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> {<span class="hljs-keyword">return</span> ({<span class="hljs-attr">title</span>: e.target.value, <span class="hljs-attr">color</span>: prev.color})})
    }
  
  <span class="hljs-keyword">const</span> handleHex = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> { 
    setNewItem( <span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> {<span class="hljs-keyword">return</span> ({<span class="hljs-attr">title</span>: prev.title, <span class="hljs-attr">color</span>: e.target.value})})
    }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span> = <span class="hljs-string">"container"</span> &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{submit}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span> = <span class="hljs-string">"color"</span> &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleHex}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{newItem.color}</span> <span class="hljs-attr">required</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span> = <span class="hljs-string">"colorName"</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleName}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{newItem.title}</span>
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"color name..."</span> <span class="hljs-attr">required</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{submit}</span>&gt;</span> + <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Όπως φαίνεται τα στοιχεία <code>&lt;input&gt;</code> της φόρμας συνοδεύονται από δύο συναρτήσεις που είναι χειριστές του συμβάντος <code>change</code> και ενημερώνουν την μεταβλητή κατάστασης <code>newItem</code>. η οποία ελέγχει το περιεχόμενο των στοιχείων. Όταν η φόρμα υποβληθεί, καλείται η συνάρτηση <code>submit()</code> η οποία καλεί τη συνάρτηση δημιουργίας νέου χρώματος <code>newColor(newItem)</code>, η οποία έχει διαβιβαστεί μέσω των ιδιοτήτων ως το στοιχείο αυτό.</p>
<div style="page-break-after: always"></div>
<h2 id="811-to-hook-useeffect">8.11 To hook UseEffect</h2>
<p>Στην ενότητα αυτή θα δούμε ένα καινούργιο hook, το <code>UseEffect</code>, που μάς επιτρέπει να εκτελεστεί ένα τμήμα κώδικα, ως επακόλουθο κάποιας αλλαγής της κατάστασης μιας ή περισσότερων μεταβλητών.</p>
<p>Σε γενικές γραμμές, αυτό το hook έχει δύο χαρακτηριστικά:</p>
<ul>
<li>μια συνάρτηση που θα καλείται</li>
<li>ένα πίνακα εξαρτήσεων που καθορίζει τις μεταβλητές οι οποίες όταν αλλάζουν θα προκαλέσουν την κλήση της συνάρτησης.</li>
</ul>
<pre class="hljs"><code><div>useEffect(συνάρτηση, [εξαρτήσεις])
</div></code></pre>
<p>Ας δούμε ένα παράδειγμα. Αν υποθέσουμε ότι κάθε φορά που αλλάζει η τιμή μιας μεταβλητής <code>count</code> (πχ. με το πάτημα ενός πλήκτρου) θέλουμε να αλλάζει και ο τίτλος της σελίδας, αυτό μπορούμε να το ορίσουμε με τον παρακάτω κώδικα:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);
 
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {   
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`Έκανες κλικ <span class="hljs-subst">${count}</span> φορές`</span>;  }, [count]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Έκανες κλικ {count} φορές<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;
        Πάτησε
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Ας δούμε στη συνέχεια μια εφαρμογή του hook αυτού στο παράδειγμα της εφαρμογής μας &quot;τα χρώματά μου&quot; που είδαμε στην προηγούμενη ενότητα.</p>
<p>Στην εφαρμογή αυτή, μετά την εισαγωγή ενός νέου χρώματος, είναι σκοπιμο να κρύψουμε τη φόρμα εισαγωγής νέου χρώματος.</p>
<p>Σε αυτήν την περίπτωση, θα θέλαμε να ορίσουμε την κατάσταση της μεταβλητής κατάστασης <code>showF</code> σε <em>false</em> κάθε φορά που τα χρώματα αλλάζουν με την προσθήκη ή τη διαγραφή ενός χρώματος, δηλαδή όταν γίνεται μεταβολή του  <code>props.colors</code> του στοιχείου <code>&lt;ColorList /&gt;</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [showF, setShowF] = useState(<span class="hljs-literal">false</span>)
  
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setShowF(<span class="hljs-literal">false</span>);
  }, [props.colors])

</div></code></pre>
<p>Στο παράδειγμα αυτό, ορίζουμε έναν πίνακα εξάρτησης που περιέχει τη μεταβλητή <code>props.colors</code>, που σημαίνει ότι το hook αυτό θα κληθεί όταν αλλάξουν τα χρώματα, δηλαδή όταν προστεθεί ένα νέο χρώμα.</p>
<p>Πρέπει να σημειώσουμε, εδώ ότι δεν θα μπορούσαμε να αλλάξουμε την μεταβλητή κατάστασης <code>showF</code> με αλλαγή των props, όπως περιγράφεταται στο <a href="https://stackoverflow.com/questions/54865764/react-usestate-does-not-reload-state-from-props">stackoverflow post</a>, καθώς οι μεταβλητές κατάστασης αρχικοποιούνται όταν δημιουργείται το στοιχείο, και όχι κάθε φορά που επανασχεδιάζεται.</p>
<p>Μια γενιότερη παρατήρηση είναι ότι όπως έχει ήδη περιγραφεί, ένα <em>στοιχείο React</em> ορίζεται με μια συνάρτηση που αναλαβαίνει να εμφανίσει ένα τμήμα της διεπαφής χρήστη. Η σχεδίαση του στοιχείου στο παράθυρο του φυλλομετρητή πραγματοποιείται όταν :</p>
<ul>
<li>
<p>η εφαρμογή φορτώνεται για πρώτη φορά, και</p>
</li>
<li>
<p>κάθε φορά που οι τιμές των <strong>ιδιοτήτων</strong> (props) και της <strong>κατάστασης</strong> αλλάζουν.</p>
</li>
</ul>
<p>Το <code>useEffect</code> hook μας επιτρέπει ακριβώς να κάνουμε ενέργειες όταν επανασχεδιάζεται ένα στοιχείο στην οθόνη.</p>
<p>Επίσης το <code>useEffect</code> είναι ιδιαίτερα χρήσιμο για τον χειρισμό ασύγχρονης ανάκτησης δεδομένων, όπως θα δούμε σε επόμενη ενότητα.</p>
<div style="page-break-after: always"></div>
<h2 id="812-%CF%87%CF%81%CE%AE%CF%83%CE%B7-%CF%84%CE%BF%CF%85-context">8.12 Χρήση του Context</h2>
<p>Μέχρι στιγμής έχουμε δει τρόπους για τη μετάδοση δεδομένων (<em>κατάστασης</em>) προς τα κάτω στα στοιχεία του React DOM μέσω των ιδιοτήτων (props) καθώς και τη μεταφορά προς τα πάνω δεδομένων με κλήση συναρτήσεων που έχουν μεταβιβαστεί ως ιδιότητες.</p>
<p>Αυτός ο τρόπος χειρισμού της κατάστασης είναι ωστόσο ιδιαίτερα σύνθετος και ευαίσθητος σε σφάλματα.</p>
<p>Το <strong>React context</strong> είναι ένα hook που προσφέρει ένα μηχανισμό δημιουργίας ενός περιβάλλοντος δεδομένων που προβλέπει τον ορισμό <em>παρόχων δεδομένων (context providers)</em> οι οποίοι μπορούν να εξυπηρετούν όλα τα στοιχεία του React DOM. * Οι καταναλωτές δεδομένων (context consumers)* στο πλαίσιο του περιβάλλοντος είναι στοιχεία που μπορούν να λάβουν τα δεδομένα που παρέχονται από τους παρόχους.</p>
<p>Στη συνέχεια θα αναδιαμορφώσουμε την εφαρμογή χρωμάτων της προηγούμενης ενότητας, τοποθετώντας τον πίνακα των χρωμάτων σε <strong>περιβάλλον (context)</strong> και καταναλώνοντας αυτό το περιβάλλον όταν χρειάζεται.</p>
<p>Προκειμένου να χρησιμοποιήσουμε το περιβάλλον, πρέπει πρώτα να τοποθετήσουμε ορισμένα δεδομένα σε έναν <strong>πάροχο δεδομένων</strong> και να προσθέσουμε αυτόν τον πάροχο στο δέντρο στοιχείων μας. Το React έρχεται με τη συνάρτηση δημιουργό &quot;createContext()&quot; που μπορεί να χρησιμοποιηθεί για τη δημιουργία ενός νέου hook τύπου περιβάλλον (context).</p>
<p>Αυτό το αντικείμενο περιέχει δύο στοιχεία: ένα πάροχο <strong>context Provider</strong> και ένα καταναλωτή δεδομένων <strong>Consumer</strong>.</p>
<h4 id="%CF%80%CF%81%CF%8E%CF%84%CE%B7-%CF%80%CF%81%CE%BF%CF%83%CF%80%CE%AC%CE%B8%CE%B5%CE%B9%CE%B1-%CF%84%CF%81%CE%BF%CF%80%CE%BF%CF%80%CE%BF%CE%AF%CE%B7%CF%83%CE%B7%CF%82-%CF%84%CE%B7%CF%82-%CE%B5%CF%86%CE%B1%CF%81%CE%BC%CE%BF%CE%B3%CE%AE%CF%82">Πρώτη προσπάθεια τροποποίησης της εφαρμογής</h4>
<p>Ας δούμε ένα παράδειγμα στην εφαρμογή &quot;χρώματα&quot;. Υπενθυμίζουμε ότι το αρχείο <code>index.js</code> στην προηγούμενη έκδοση της εφαρμογής ήταν απλά:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/App"</span>;

<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);
ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, rootElement);
</div></code></pre>
<p>Η νέα έκδοση του <code>index.js</code>   περιλαμβάνει τη δημιουργία του αντικειμένου <code>ColorContext</code> που επιστρέφει η δημιουργός <code>createContext();</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;
<span class="hljs-keyword">import</span> React, {createContext} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/App"</span>;
<span class="hljs-keyword">import</span> colorData <span class="hljs-keyword">from</span> <span class="hljs-string">"./colors.json"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ColorContext = createContext();

<span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>);
ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ColorContext.Provider</span> <span class="hljs-attr">value</span> = <span class="hljs-string">{{colorData}}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ColorContext.Provider</span>&gt;</span></span>, 
    rootElement
);
</div></code></pre>
<p>Ένα context hook, όπως το <code>ColorContext</code> περιέχει δύο γνωρίσματα:  <code>{ Provider, Consumer }</code>. Το στοιχείο <code>&lt;ColorContext.Provider /&gt;</code> χρησιμοποιείται για την διαθέσει τα δεδομένα στους απογόνους του στην ιεαραρχία στοιχείων React.</p>
<p>Στο αντικείμενο αυτό περνάμε ως ιδιότητα τα δεδομένα μας στην ιδιότητα <code>value</code>.</p>
<p>Στη συνέχεια ενθυλακώνουμε το στοιχείο <code>&lt;App /&gt;</code> στο στοιχείο αυτό, και συνεπώς παρέχουμε σε όλα τα στοιχεία του δένδρου μας πρόσβαση στα δεδομένα του context.</p>
<p>Η κατανάλωση των δεδομένων αυτών γίνεται ως εξής:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { colors } = useContext(ColorContext);
</div></code></pre>
<h4 id="%CE%B4%CE%B5%CF%8D%CF%84%CE%B5%CF%81%CE%B7-%CF%80%CF%81%CE%BF%CF%83%CF%80%CE%AC%CE%B8%CE%B5%CE%B9%CE%B1-%CF%84%CF%81%CE%BF%CF%80%CE%BF%CF%80%CE%BF%CE%AF%CE%B7%CF%83%CE%B7%CF%82-%CF%84%CE%B7%CF%82-%CE%B5%CF%86%CE%B1%CF%81%CE%BC%CE%BF%CE%B3%CE%AE%CF%82">Δεύτερη προσπάθεια τροποποίησης της εφαρμογής</h4>
<p>Θα δούμε στη συνέχεια μια νεότερη έκδοση της εφαρμογής, γιατί η προσέγγιση που αναφέρθηκε παρουσιάζει προβλήματα. Ο καταναλωτής έχει πρόσβαση στα δεδομένα, αλλά δεν μπορεί να τροποποιήσει τη μεταβλητή <code>color</code>. Στο παράδειγμά μας, όπως είδαμε σε προηγούμενες ενότητες, οι χρήστες πρέπει να μπορούν να προσθέσουν νέα χρώματα, να διαγράψουν χρώματα και να βαθμολογήσουν τα χρώματα. Για να γίνει κάτι τέτοιο χρειάζεται η εισαγωγή ενός παρόχου περιβάλλοντος (provider) ο οποίος να περιέχει δεδομένα state.</p>
<p>Έτσι θα πρέπει να δημιουργήσουμε ένα νέο στοιχείο που θα είναι ο πάροχος του colorContext, που θα περιέχει τα δεδομένα κατάστασης και θα επιτρέπει μέσω κατάλληλων συναρτήσεων ο χρήστης να τροποποιήσει τα δεδομένα αυτά, δηλαδή να προσθέσει χρώματα, να αφαιρέσει χρώματα και να βαθμολογήσει τα χρώματα.</p>
<p>Το νέο αυτό στοιχείο περιέχεται στο αρχείο <code>ColorProvider.jsx</code> και παρουσιάζεται στη συνέχεια.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, {createContext, useState} <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> colorData <span class="hljs-keyword">from</span> <span class="hljs-string">"../colors.json"</span>;

<span class="hljs-comment">// δημιουργούμε Context για το state .</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ColorContext = createContext();
<span class="hljs-comment">// δημιουργούμε ένα Provider object με τα δεδομένα του</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ColorProvider</span> (<span class="hljs-params">{ children }</span>) </span>{
  <span class="hljs-keyword">const</span> [colors, setColors] = useState(colorData);
  <span class="hljs-keyword">const</span> totalStars = <span class="hljs-number">5</span>;

  <span class="hljs-keyword">const</span> newColor = (newColor){
    <span class="hljs-keyword">if</span> (colors.length &gt; <span class="hljs-number">0</span>)
      newColor[<span class="hljs-string">'id'</span>] = (<span class="hljs-built_in">parseInt</span>(colors[colors.length<span class="hljs-number">-1</span>].id) + <span class="hljs-number">1</span>).toString()
    <span class="hljs-keyword">else</span> newColor[<span class="hljs-string">'id'</span>] = <span class="hljs-string">"0"</span>
    newColor[<span class="hljs-string">'stars'</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> colorsNew = [...colors, newColor]
    setColors(colorsNew);
  }
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rateColor</span>(<span class="hljs-params">id, star, totalStars</span>)</span>{
    <span class="hljs-comment">// αλλαγή βαθμολογίας χρώματος id</span>
    <span class="hljs-keyword">if</span> (star&gt;=<span class="hljs-number">0</span> &amp;&amp; star &lt;= totalStars) {
    setColors (<span class="hljs-function">(<span class="hljs-params">prev</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> prev.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (item.id === id){
          <span class="hljs-keyword">return</span> {...item, <span class="hljs-string">'rating'</span>: star+<span class="hljs-number">1</span>}
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> item;})
    })}
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeColor</span>(<span class="hljs-params">id</span>)</span>{
    setColors(<span class="hljs-function">(<span class="hljs-params">prev</span>)=&gt;</span>{
      <span class="hljs-keyword">return</span> prev.filter(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>item.id !== id)
      })
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ColorContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">colors</span>, <span class="hljs-attr">addColor</span>, 
    <span class="hljs-attr">removeColor</span>, <span class="hljs-attr">rateColor</span>, <span class="hljs-attr">totalStars</span> }}&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ColorContext.Provider</span>&gt;</span></span>);
};
</div></code></pre>
<p>Στη συνέχεια στο στοιχείο <code>&lt;App /&gt;</code>, χρησιμοποιούμε το στοιχείο αυτό ως το στοιχείο ρίζα του δένδρου μας, στο οποίο ενθυλακώνουμε τα υπόλοιπα στοιχεία.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ColorProvider</span> &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ColorList</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ColorProvider</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Ακολούθως, σε όλα τα στοιχεία στα οποία χρειαζόμαστε πρόσβαση στα στοιχεία της διεπαφής μας, όπως πρόσβαση στις συναρτήσεις τροποποίησης των χρωμάτων, ή στα δεδομένα των χρωμάτων, περιλαμβάνουμε τον παρακάτω κώδικα:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> {ColorContext} <span class="hljs-keyword">from</span> <span class="hljs-string">"./ColorProvider"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Xyz</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">const</span> value = useContext(ColorContext)
  <span class="hljs-comment">// εδώ χρησιμοποιούμε value.colors, κλπ.</span>
  ...
}
</div></code></pre>
<p>Με τον τρόπο αυτό σε οποιοδήποτε σημείο του δένδρου μας μπορούμε να έχουμε πρόσβαση στα στοιχεία κατάστασης, αλλά και στις συναρτήσεις που επιτρέπουν την τροποποίησή τους.</p>
<p>Θα πρέπει να σημειωθεί ότι η διαχείριση των δεδομένων κατάστασης γίνεται πιο αποτελεσματικά με αυτόν τον τρόπο. Επίσης θα μπορούσαμε να δημιουργήσουμε πολλαπλά αντικείμενα πλαισίου και αντίστοιχους παρόχους, αν χρειαζόταν.</p>
<p>Ο τρόπος που παρουσιάστηκε εδώ για διαχείριση κατάστασης, τείνει να αντικαταστήσει ειδικά framework διαχείρισης κατάστασης, όπως το <strong>redux</strong>, που χρησιμοποιούνται για διαχείριση κατάστασης σε εφαρμογές React. Όμως αυτές οι λύσεις παραμένουν ως εναλλακτικές λύσεις, ιδιαίτερα για απαιτητικές εφαρμογές με πολλά δεδομένα.</p>
<div style="page-break-after: always"></div>
<h2 id="813-%CE%B1%CE%BD%CE%AC%CE%BA%CF%84%CE%B7%CF%83%CE%B7-%CE%B4%CE%B5%CE%B4%CE%BF%CE%BC%CE%AD%CE%BD%CF%89%CE%BD-%CE%BC%CE%B5-fetch">8.13 Ανάκτηση δεδομένων με fetch</h2>
<p>Η διεπαφή Fetch είναι ο πιο διαδεδομένος και εύκολος τρόπος για ασύγχρονη ανάκτηση δεδομένων από εξυπηρετητές ή από διεπαφές REST.</p>
<p>Για παράδειγμα, αν επιθυμούμε να ανακτήσουμε δεδομένα για την Ελλάδα από το API <code>https://restcountries.eu/rest/v2/name/Greece</code>  ώστε να τα παρουσιάσουμε στην κονσόλα μας, ειδού ένα σύντομο πρόγραμμα που το κάνει:</p>
<pre class="hljs"><code><div>fetch(<span class="hljs-string">`https://restcountries.eu/rest/v2/name/Greece`</span>)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(<span class="hljs-built_in">console</span>.log)
  .catch(<span class="hljs-built_in">console</span>.error);
</div></code></pre>
<p>H κλήση της διεπαφής Fetch επιστρέφει μια υπόσχεση (promise), το αποτέλεσμα της οποίας καταναλώνει η μέθοδος <code>then()</code>. Επειδή και αυτή επιστρέφει promise, μπορούμε να διαχειριστούμε τα δεδομένα σε μια αλυσίδα από κλήσεις της.</p>
<p>Σε μια εφαρμογή React, αν επιθυμούμε να αποθηκεύσουμε τα ανακτηθέντα δεδομένα και να τα διαχειριστούμε πρέπει να δημιουργήσουμε μια μεταβλητή κατάστασης και να χρησιμοποιήσουμε το hook <code>useEffect()</code> ώστε να τρέξει όταν φορτωθεί το στοιχείο React στο οποίο ανήκει.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [data, setData] = useState({<span class="hljs-string">"state"</span>: <span class="hljs-string">"loading..."</span>})

useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  fetch(<span class="hljs-string">`https://restcountries.eu/rest/v2/name/Greece`</span>)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(<span class="hljs-function">(<span class="hljs-params">resp</span>) =&gt;</span> setData(resp[<span class="hljs-number">0</span>]))
  .catch(<span class="hljs-built_in">console</span>.error);
  }, [data])
</div></code></pre>
<p>Θα πρέπει να προσέξουμε το δεύτερο όρισμα της <code>useEffect()</code> που περιέχει ένα πίνακα με τα αντικείμενα τα οποία αν αλλάξουν προκαλούν νέα κλήση της συνάρτησης. Αν παραληφθεί το δεύτερο όρισμα, η συνάρτηση καλείται συνεχώς, αν οριστεί ως κενός πίνακας <code>[]</code>, τότε καλείται μόνο μια φορά όταν πρωτο-σχεδιάζεται το στοιχείο. Στην περίπτωσή μας αν επιθυμούμε να καλείτει κάθε φορά που αλλάζει η μεταβλητή <code>data</code>, θέτουμε το δεύτερο όρισμα σε <code>[data]</code>.</p>
<p>Εννοείται ότι στη συνέχεια μπορούμε να χειριστούμε τα δεδομένα αυτά χρησιμοποιώντας μηχανισμούς όπως το hook <code>useContext()</code> που είδαμε στην προηγούμενη ενότητα.</p>
<h5 id="%CE%B4%CE%B7%CE%BC%CE%B9%CE%BF%CF%85%CF%81%CE%B3%CE%AF%CE%B1-%CE%B5%CE%BD%CF%8C%CF%82-hook-usefetch">Δημιουργία ενός hook <code>useFetch()</code></h5>
<p>Είναι καλή ιδέα να χειριστούμε όλες τις πιθανές καταστάσεις στις οποίες εισέρχεται το αντικείμενο της κλήσης fetch(), όπως την κατάσταση <em>φόρτωσης (loading)</em>, ενώ η φόρτωση δεν έχει ολοκληρωθεί ακόμη, την κατάσταση <em>σφάλματος</em> αν η υπόσχεση δεν εκπληρωθεί, και την κατάσταση επιτυχούς ανάκτησης των δεδομένων, όταν εκπληρωθεί επιτυχώς η υπόσχεση.</p>
<p>Μπορούμε να δημιουργήσουμε ένα hook <code>useFetch()</code> ώστε να χειριστούμε με αυτόν και τις τρεις καταστάσεις, μέσω μεταβλητών κατάστασης. Αυτό είναι ένα παράδειγμα δημιουργίας νέου hook, κάτι που προτείνεται ως καλή πρακτική από τη React.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFetch</span>(<span class="hljs-params">uri</span>) </span>{
  <span class="hljs-keyword">const</span> [data, setData] = useState();
  <span class="hljs-keyword">const</span> [error, setError] = useState();
  <span class="hljs-keyword">const</span> [loading, setLoading] = useState(<span class="hljs-literal">true</span>);
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!uri) <span class="hljs-keyword">return</span>;
    fetch(uri)
    .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> data.json())
    .then(setData)
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setLoading(<span class="hljs-literal">false</span>))
    .catch(setError);
  }, [uri]);
  <span class="hljs-keyword">return</span> { loading, data, error};
}
</div></code></pre>
<p>Αυτό το νέο hook που δημιουργήθηκε μπορεί να χρησιμοποιηθεί ως ένα στοιχείο React ως ακολούθως:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fetch</span>(<span class="hljs-params">{ url, renderSuccess,
  loadingFallback = &lt;p&gt;loading...&lt;<span class="hljs-regexp">/p&gt;,
  renderError = error =&gt; (
    &lt;pre&gt;{JSON.stringify(error, null, 2)}&lt;/</span>pre&gt;</span>)
  }) </span>{
    <span class="hljs-keyword">const</span> { loading, data, error } = useFetch(url);
    <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> loadingFallback;
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> renderError(error);
    <span class="hljs-keyword">if</span> (data) <span class="hljs-keyword">return</span> renderSuccess({ data });
}
</div></code></pre>
<p>Το στοιχείο αυτό μπορούμε να το χρησιμοποιήσουμε ως εξής:</p>
<pre class="hljs"><code><div>&lt;Fetch
  url={<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${login}</span>`</span>}
  renderSuccess={data}
/&gt;
</div></code></pre>
<h4 id="%CF%80%CE%B1%CF%81%CE%AC%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1---%CE%AC%CF%83%CE%BA%CE%B7%CF%83%CE%B7">Παράδειγμα - άσκηση</h4>
<p>Να ανακτήσετε πληροφορίες και τη σημαία από τη διεπαφή:  <code>https://restcountries.eu/rest/v2/name/${country}</code>.
Να χρησιμοποιήσετε το στοιχείο <code>&lt;Fetch /&gt;</code>.</p>
<p><a href="https://csb-yt6u4.netlify.app/">Παράδειγμα υλοποίησης της άσκησης από το netlify</a></p>
<img src="flags-fetch.png" width="250" style="border: 1px solid grey">
<div style="page-break-after: always"></div>
<h2 id="814-%CE%B4%CE%B9%CE%B1%CF%87%CE%B5%CE%AF%CF%81%CE%B9%CF%83%CE%B7-%CE%BC%CE%B5%CE%B3%CE%AC%CE%BB%CF%89%CE%BD-%CE%BB%CE%B9%CF%83%CF%84%CF%8E%CE%BD-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CF%89%CE%BD">8.14 Διαχείριση μεγάλων λιστών στοιχείων</h2>
<p>Συχνά, τα δεδομένα που θα παρουσιαστούν στον χρήστη είναι πολύ περισσότερα από την χωρητικότητα της οθόνης ή του φυλλομετρητή ή η διαχείρισή τους θα προκαλούσε υποβάθμιση της απόδοσης του φυλλομετρητή, λόγω του μεγάλου όγκου.
Σε αυτήν την περίπτωση οι <strong>εικονικές λίστες</strong> μπορούν να χειριστούν τις πληροφορίες σταδιακά.</p>
<p>Μια <em>εικονική λίστα</em> είναι μια λίστα δεδομένων που περιέχει τόσα δεδομένα όσα χρειάζονται για να γεμίσουν το παράθυρο καθώς και ορισμένα δεδομένα πριν και μετά, ώστε να ανταποκριθεί στην κύλιση προς τα πάνω ή προς τα κάτω. Υπάρχουν πολλοί ιστότοποι που χειρίζονται τεράστιες ποσότητες δεδομένων και χρησιμοποιούν τέτοια στοιχεία.</p>
<img src="virtual-list.png" width="150px">
<p>Στη React, το στοιχείο αυτό μπορεί να υλοποιηθεί χρησιμοποιώντας το στοιχείο <code>FixedSizeList</code> της βιβλιοθήκης <code>react-window</code> η οποία εισάγεται ως εξής:</p>
<p><code>npm i react-window</code></p>
<p>Μετά την εγκατάσταση της <code>react-window</code> πρέπει να εισάγουμε το σχετικό στοιχείο ως εξής:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { FixedSizeList } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-window"</span>;
</div></code></pre>
<p>Ας δημιουργήσουμε ένα παράδειγμα τέτοιου στοιχείου που περιέχει τα δεδομένα χρηστών. Δεδομένου ότι χρειαζόμαστε πολλά δεδομένα, μπορούμε να χρησιμοποιήσουμε το <code>faker</code> ένα module για τη δημιουργία πλαστών δεδομένων.</p>
<p><code>npm i faker</code></p>
<p>Επιπλέον, ορισμένες τυχαίες εικόνες μπορούν να συλλεγούν από τον ιστότοπο lorem.picsum για να χρησιμοποιηθούν ως εικόνες των χρηστών.</p>
<p>Μια μεγάλη λίστα με 50000 χρήστες, που περιέχει ονόματα, μηνύματα ηλεκτρονικού ταχυδρομείου και εικόνες, μπορεί να δημιουργηθεί χρησιμοποιώντας τα faker και picsum, ως εξής:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> faker <span class="hljs-keyword">from</span> <span class="hljs-string">"faker"</span>;
<span class="hljs-keyword">const</span> userList = [...Array(<span class="hljs-number">50000</span>)].map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
  <span class="hljs-attr">name</span>: faker.name.findName(),
  <span class="hljs-attr">email</span>: faker.internet.email(),
  <span class="hljs-attr">avatar</span>: <span class="hljs-string">`https://picsum.photos/30.jpg?random=<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">50</span>)}</span>`</span>
}));
</div></code></pre>
<p>Μπορούμε να χρησιμοποιήσουμε αυτό το στοιχείο για την εμφάνιση μιας μεγάλης λίστας χρηστών.</p>
<p>Το FixedSizeList απαιτεί ως ορίσματα το σύνολο
του αριθμού στοιχείων της λίστας (ιδιότητα <code>itemCount</code>) μαζί με τον αριθμό pixel που απαιτεί κάθε σειρά (ιδιότητα <code>itemSize</code>). Απαιτεί επίσης το ύψος και το πλάτος του παράθυρου προβολής (ιδιότητες <code>ύψος</code> και <code>πλάτος</code>) .
Το στοιχείο <code>&lt;FixedSizeList&gt;</code> λαμβάνει ως παιδί τη  <code>renderRow</code>, η οποία είναι μια συνάρτηση που επιστρέφει ένα στοιχείο React προς εμφάνιση, δηλαδή είναι, όπως λέγεται, ένα render prop.</p>
<p>Το παράδειγμα χρήσης του FixedSizeList για την εμφάνιση αυτής της μεγάλης λίστας χρηστών είναι το ακόλουθο:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { FixedSizeList } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-window"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> renderRow = <span class="hljs-function">(<span class="hljs-params">{ index, style }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"contact"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">...style</span>, <span class="hljs-attr">...</span>{ <span class="hljs-attr">display:</span> "<span class="hljs-attr">flex</span>" } }}&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span>
      <span class="hljs-attr">src</span>=<span class="hljs-string">{userList[index].avatar}</span>
      <span class="hljs-attr">alt</span>=<span class="hljs-string">{userList[index].name}</span>
      <span class="hljs-attr">height</span>=<span class="hljs-string">{30}</span>
      <span class="hljs-attr">width</span>=<span class="hljs-string">{30}/</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"name"</span>&gt;</span> {userList[index].name} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"email"</span>&gt;</span> {userList[index].email} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FixedSizeList</span> <span class="hljs-attr">className</span> = <span class="hljs-string">"App"</span>
          <span class="hljs-attr">height</span>=<span class="hljs-string">{window.innerHeight}</span>
          <span class="hljs-attr">width</span>=<span class="hljs-string">{window.innerWidth</span> <span class="hljs-attr">-</span> <span class="hljs-attr">20</span>}
          <span class="hljs-attr">itemCount</span>=<span class="hljs-string">{userList.length}</span>
          <span class="hljs-attr">itemSize</span>=<span class="hljs-string">{70}</span>&gt;</span>
      {renderRow}
    <span class="hljs-tag">&lt;/<span class="hljs-name">FixedSizeList</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>Παρατίθεται επίσης μια απεικόνισης της λειτουργίας αυτού του κώδικα, καθώς και <a href="https://csb-p8wds.netlify.app/">υλοποίηση του στο netlify</a>.</p>
<img src="virtual-list-example.png" width="300">
<div style="page-break-after: always"></div>
<h2 id="815-%CE%B4%CE%B9%CE%B5%CF%80%CE%B1%CF%86%CE%AE-%CF%84%CE%B7%CF%82-graphql-%CE%BC%CE%B5-%CE%BC%CE%B9%CE%B1-%CE%B5%CF%86%CE%B1%CF%81%CE%BC%CE%BF%CE%B3%CE%AE-react">8.15 Διεπαφή της GraphQL με μια εφαρμογή React</h2>
<h4 id="%CF%83%CF%8D%CE%BD%CF%84%CE%BF%CE%BC%CE%B7-%CE%B5%CE%B9%CF%83%CE%B1%CE%B3%CF%89%CE%B3%CE%AE-%CF%83%CF%84%CE%B7-graphql">Σύντομη εισαγωγή στη GraphQL</h4>
<p>Μέχει τώρα έχουμε ανακτήσει δεδομένα με χρήση διεπαφών REST, όπως το API <code>https://restcountries.eu/rest/v2</code> για ανάκτηση γεωγραφικών πληροφοριών για τις χώρες του κόσμου.</p>
<p>Αυτού του τύπου η διεπαφή ορίζεται από ένα αριθμό από διακριτά σημεία επαφής, όπως περιγράφεται στο <a href="https://restcountries.eu/">https://restcountries.eu/</a></p>
<p>Τέτοια σημεία επαφής για το παράδειγμα μας είναι:</p>
<ul>
<li><code>https://restcountries.eu/rest/v2/name/{name}</code> που επιτρέπει αναζήτηση χωρών με το όνομά τους,</li>
<li><code>https://restcountries.eu/rest/v2/alpha/{code}</code> με κωδικό 2 ή 3 χαρακτήρων χώρας (GR, κλπ.),</li>
<li><code>https://restcountries.eu/rest/v2/lang/{et}</code> αναζτήση με τον κωδικό ISO 639-1 μιας γλώσσας, κλπ.</li>
</ul>
<p>Αυτό το τελευταίο σημείο επαφής μάς επιστρέφει τις χώρες στην οποία η συγκεκριμένη χώρα ομιλείται (δηλαδή χώρες οι οποίες περιέχουν τον συγκεκριμένο κωδικό γλώσσας κατά ISO, στον πίνακα languages).<br>
Κατά συνέπεια όταν προσπελάσουμε το σημείο επαφής με το URL <code>https://restcountries.eu/rest/v2/lang/es</code> λαμβάνουμε τα δεδομένα και των 23 χωρών στις οποίες ομιλείται η Ισπανική γλώσσα.</p>
<p>Όμως αν επιθυμούσαμε να λάβουμε μόνο τα ονόματα των χωρών που ομιλείται η Ισπανική και όχι όλες τις πληροφορίες των χωρών, δεν είναι δυνατόν να απομονώσουμε αυτή την πληροφορία, έτσι το αποτέλεσμα είναι να λαβαίνουμε με κάθε κλήση της διεπαφής πρόσθετη πληροφορία που δεν χρειαζόμαστε.</p>
<p>Αυτό το πρόβλημα λέγεται <strong>υπερ-ανάκτηση</strong> <strong>(overfetching)</strong>, που περιγράφει την κατάσταση κατά την οποία λαμβάνουμε περισσότερη πληροφορία από όση είναι απαραίτητη.</p>
<p>Ένα άλλο πρόβλημα που εμφανίζεται σε διεπαφές τύπου REST είναι συχνά να εμφανίζονται περιπτώσεις κατά τις οποίες για να ανακτήσουμε την πληροφορία που χρειαζόμαστε, αναγκαζόμαστε να καταφύγουμε σε πολλαπλά σημεία επαφής και να συνδυάσουμε τα δεδομένα που αυτά μάς επιστρέφουν, αφού δεν υπάρχει ένα μόνο σημείο που να καλύπτει όλες τις ανάγκες μας. Αυτό το πρόβλημα λέγεται πρόβλημα <strong>υπό-ανακτησης</strong> <strong>(underfetching)</strong>.</p>
<p>Η <strong>GraphQL</strong> είναι ένα πρότυπο διεπαφής το οποίο μάς προσφέρει ένα πιο αποτελεσματικό και αποδοτικό τρόπο ανάκτησης δεδομένων από ότι οι διεπαφές τύπου REST. Το πρότυπο αυτό έχει επίσης προταθεί από την Facebook (2015), την εταιρία που δημιούργησε τη React, όμως δεν σχετίζεται απαραίτητα με εφαρμογές React, και αποτελεί σήμερα ένα ευρύτερα διαθέσιμο πρότυπο τεχνολογίας προσφοράς και ανάκτησης δεδομένων.</p>
<p>Η GraphQL προσφέρει τη δυνατότητα ορισμού ενός μοναδικού σημείου επαφής API που να ικανοποιεί αιτήματα για δεδομένα πολλαπλών μορφών και περιεχομένου. Η χρήση της ελαχιστοποιεί τα δεδομένα που ανακτώνται από τον εξυπηρετητή στον πελάτη. Στέλνουμε ένα μόνο αίτημα που περιγράφει σαφώς τα δεδομένα που χρειαζόμαστε με μια περιγραφή που μοιάζει με τις γλώσσες ερωτήσεων στις βάσεις δεδομένων, όπως η SQL SELECT και η find() της MongoDB.</p>
<p>Για μια πλήρη περιγραφή της τεχνολογίας αυτής, η οποία είναι αρκετά σύνθετη, ιδιαίτερα ως προς τον ορισμό μιας τέτοιας διεπαφής, μπορεί να βρει κανείς στο <a href="https://www.howtographql.com/">howtoGraphQL</a>.</p>
<p>Η γλώσσα ορισμού του Σχήματος (Schema Definition Language) μιας διεπαφής GraphQL έχει την παρακάτω δομή:</p>
<pre class="hljs"><code><div>type Person {
  name: String!
  age: Int!
  posts: [Post!]!
}
type Post {
  title: String!
  author: Person!
}
</div></code></pre>
<p>Το σχήμα αυτό αφορά δύο οντότητες (τύπους δεδομένων) την <code>Person</code> και την <code>Post</code>, περιγράφει τις ιδιότητές τους, καθώς επίσης ορίζει μια συσχέτιση τύπου ένα-προς-πολλά μεταξύ των τύπων Person και Post. Επίσης να σημειώσουμε ότι το σύμβολο ! δηλώνει υποχρεωτικό πεδίο.</p>
<p>Τα κύρια στοιχεία της GraphQL API είναι:</p>
<ul>
<li>ερωτήματα (queries)</li>
<li>μεταβολές (mutations) όπως εισαγωγή, τροποποίηση και διαγραφή δεδομένων</li>
</ul>
<p>Υπάρχουν αρκετές πηγές δεδομένων, ακόμη και δημόσια διαθέσιμων που ακολουθούν το πρότυπο graphQL. Μια λίστα από δημόσια τέτοια σημεία επαφής με τα οποία θα μπορούσε να πειραματιστεί κανείς ή να τα χρησιμοποιήσει για άντληση δεδομένων περιέχεται στο <a href="https://github.com/APIs-guru/graphql-apis">github graphQL APIs list</a>.</p>
<h4 id="%CE%AD%CE%BD%CE%B1-%CF%80%CE%B1%CF%81%CE%AC%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1-graphql-api">Ένα παράδειγμα GraphQL API</h4>
<p>Μπορούμε να χρησιμοποιήσουμε τη δημόσια διαθέσιμη διεπαφή graphQL API για τα γεωγραφικά δεδομένα χωρών, το <a href="https://countries-274616.ew.r.appspot.com/">countires v.2 api</a>, μια πειραματική διάθεση των δεδομένων αυτών από την πλατφόρμα google apps.</p>
<p>Αν το σημείο επαφής αυτό δεν είναι πλήρως λειτουργικό, μπορούμε εναλλακτικά να χρησιμοποιήσουμε ένα άλλο απλούστερο σημείο επαφής, το <a href="https://countries.trevorblades.com/">counties api</a>.</p>
<p>Σε κάθε περίπτωση στο <a href="https://github.com/lennertVanSever/graphcountries">repo του L. Van Sever</a> που συντηρεί αυτό το πρότζεκτ, υπάρχουν διαθέσιμες οδηγίες για στήσιμο ενός εξυπηρετητή της βάσης αυτής γεωγραφικών δεδομένων.</p>
<p>Στο παρακάτω παράδειγμα έχει χρησιμοποιηθεί το πρώτο σημείο επαφής.</p>
<p>Αν επιλέξουμε το σημείο επαφής, θα συνδεθούμε σε ένα διαδραστικό περιβάλλον στο οποίο περιλαμβάνονται το σχήμα της βάσης, η τεκμηρίωση και η δυνατότητα να πειραματιστούμε με τη διεπαφή. Το περιβάλλον αυτό είναι το GraphQL Playground ένα γραφικό, διαδραστικό, GraphQL IDE που δημιουργήθηκε από παρέχεται από τον εξυπηρετητή  Apollo κατά τη φάση ανάπτυξης μιας διεπαφής graphQL.</p>
<p>Θα πρέπει να σημειωθεί ότι οι <a href="https://www.apollographql.com/docs/">Apollo Client και Apollo Server</a> είναι από τις πιο διαδεδομένες λύσεις για την ανάπτυξη εξυπηρετητή ή σύνδεση πελάτη με graphQL. Υπάρχουν βεβαίως και άλλες εναλλακτικές λύσεις. Στην επόμενη ενότητα θα χρησιμοποιήσουμε μια άλλη πιο απλή βιβλιοθήκη για σύνδεση σε ένα σημείο επαφής graphQL.</p>
<img src="graphQL-playground.png">
<p><em>To graphQL playground</em>.</p>
<p>Μια δυνατότητα που παρέχεται είναι με χρήση ενδοσκόπησης στο σχήμα, μπορούμε να ανακτήσουμε pληροφορίες για αυτό,  όπως για παράδειγμα για τον τύπο δεδομένων Country:</p>
<pre class="hljs"><code><div>query {
   __type(name:&quot;Country&quot;) {
      fields {name}  
   }
}
</div></code></pre>
<p>Το αποτέλεσμα αυτής της αναζήτησης είναι το σχήμα (schema) του τύπου δεδομένων Country:</p>
<pre class="hljs"><code><div>{
  &quot;data&quot;: {
    &quot;__type&quot;: {
      &quot;fields&quot;: [
        {&quot;name&quot;: &quot;_id&quot;},
        ...
        {&quot;name&quot;: &quot;borders&quot;},
        {&quot;name&quot;: &quot;flags&quot;},
        {&quot;name&quot;: &quot;officialLanguages&quot;},
        ...
      ]
    }
  }
}
</div></code></pre>
<p>Μετά από μελέτη του σχήματος (που μπορούμε να βρούμε επίσης στο Documentation του περιβάλλοντος) ανακαλύπτουμε ότι το πεδίο &quot;borders&quot;  δέχεται μια συνάθροιση στοιχείων τύπου Country:</p>
<p><code>borders(...): [Country]</code>,</p>
<p>Αυτές είναι οι χώρες που συνορεύουν με τη χώρα.</p>
<p>Επίσης το πεδίο &quot;flag&quot; περιέχει δεδομένα τύπου Flag:</p>
<p><code>flag(...): Flag</code></p>
<p>Αν εξετάσουμε περαιτέρω το τύπο δεδομένων <code>Flag</code> αυτός ορίζεται ως ακολούθως:</p>
<pre class="hljs"><code><div>type Flag {
  _id: String
  emoji: String!
  emojiUnicode: String!
  svgFile: String!
  country(...): Country
}
</div></code></pre>
<p>Με βάση τα παραπάνω αν επιθυμούμε πληροφορίες για γειτονικές χώρες, πχ. τα emojis των γειτονικών χωρών, καθώς και τη σημαία μιας χώρας, (πχ της χώρας &quot;Greece&quot;), διατυπώνουμε σε graphQL την ακόλουθη ερώτηση:</p>
<pre class="hljs"><code><div>query {
  Country (name: &quot;Greece&quot;){
    flag {emoji}
    borders {
      flag { emoji }
    }
  }}
</div></code></pre>
<p>Όταν διατυπώσουμε την ερώτηση αυτή στο περιβάλλον του graphQL playground, λαμβάνουμε την παρακάτω απάντηση:</p>
<pre class="hljs"><code><div>{
  &quot;data&quot;: {
    &quot;Country&quot;: [
      {
        &quot;flag&quot;: {&quot;emoji&quot;: &quot;🇬🇷&quot;},
        &quot;borders&quot;: [
          {&quot;flag&quot;: {&quot;emoji&quot;: &quot;🇹🇷&quot;}},
          {&quot;flag&quot;: {&quot;emoji&quot;: &quot;🇲🇰&quot;}},
          {&quot;flag&quot;: {&quot;emoji&quot;: &quot;🇧🇬&quot;}},
          {&quot;flag&quot;: {&quot;emoji&quot;: &quot;🇦🇱&quot;}}]
      }]
  }}
</div></code></pre>
<p>Από το παραπάνω παράδειγμα έχουμε μια εικόνα για τη γλώσσα σύνταξης ερωτήσεων προς ένα σημείο επαφής της graphQL, καθώς και τη δομή της απάντησης που λαμβάνουμε, που είναι ένα αντικείμενο JSON με μοναδικό γνώρισμα &quot;data&quot; που περιλαμβάνει τα δεδομένα που ικανοποιούν την απάντηση.</p>
<p>Στη συνέχεια θα δούμε ένα παράδειγμα χρήσης της διεπαφής αυτής από μια εφαρμογή React.</p>
<h4 id="%CF%80%CE%B1%CF%81%CE%AC%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1-%CF%87%CF%81%CE%AE%CF%83%CE%B7%CF%82-%CE%B4%CE%B9%CE%B5%CF%80%CE%B1%CF%86%CE%AE%CF%82-graphql">Παράδειγμα χρήσης διεπαφής GraphQL</h4>
<p>Η εφαρμογή αυτή είναι επεκτείνει την εφαρμογή που είχαμε δημιουργήσει για τη διεπαφή REST των γεωγραφικών δεδομένων χωρών, αυτή τη φορά χρησιμοποιώντας την διεπαφή GraphQL.</p>
<p>Χρησιμοποιώντας το σημείο επαφής <a href="https://countries.trevorblades.com/">counties api</a> με χρήση του κωδικού μιας συγκεκριμένης χώρας, θα ζητήσουμε το όνομα της συγκεκριμένης χώρας, το όνομα της πρωτεύουσάς της, καθώς και τη σημαία της ως emoji. Να σημειωθεί εδώ ότι η συγκεκριμένη διεπαφή είναι απλούστερη από την αντίστοιχη διεπαφή REST αφού περιλαμβάνει μόνο τα emojis των σημαιών.</p>
<pre class="hljs"><code><div>query {
	country(code:&quot;IS&quot;){
    name
    capital
    emoji
  }
}
</div></code></pre>
<p>Η απόκριση που λαμβάνουμε από τη συγκεκριμένη ερώτηση είναι:</p>
<pre class="hljs"><code><div>{
  &quot;data&quot;: {
    &quot;country&quot;: {
      &quot;name&quot;: &quot;Iceland&quot;,
      &quot;capital&quot;: &quot;Reykjavik&quot;,
      &quot;emoji&quot;: &quot;🇮🇸&quot;
    }
  }
}
</div></code></pre>
<h4 id="%CF%85%CE%BB%CE%BF%CF%80%CE%BF%CE%AF%CE%B7%CF%83%CE%B7-%CF%84%CE%BF%CF%85-client">Υλοποίηση του client</h4>
<p>Η απόκριση που παίρνουμε όταν υλοποιήσουμε την εφαρμογή που εκτελεί το ερώτημα της προηγούμενης ενότητας φαίνεται στη συνέχεια:</p>
<img src="graphQL-example.png" style="border:1px solid grey">
<p>Στο συγκεκριμένο παράδειγμα θα χρησιμοποιήσουμε τη βιβλιοθήκη πελάτη της GraphQL.</p>
<p>Όπως ήδη αναφέρθηκε η πιο συνηθισμένη βιβλιοθήκη για πελάτη GraphQL είναι η βιβλιοθήκη <code>apollo client</code>. Τεκμηρίωση και παραδείγματα χρήσης υπάρχουν στα <a href="https://www.apollographql.com/docs/react/get-started/">Apollo docs</a>.</p>
<p>Αν προσπαθήσετε να εγκαταστήσετε αυτό το πακέτο, θα παρατηρήσετε ότι εγκαθίστανται μια σειρά από εξαρτήσεις, μαζί πρέπει να εγκαταστήσουμε το πακέτο graphql που μάς επιτρέπει την συντακτική ανάλυση ερωτημάτων graphql:</p>
<p><code>npm install @apollo/client graphql</code></p>
<p><em>υποσημείωση: το σύμβολο @ στο όνομα αυτού του package, σημαίνει ότι αυτό είναι ένα επίσημο apollo package και ότι ο ιδιοκτητης του πακέτου έχει δικαίωμα να αναπτύσσει υπό-πακέτα όπως ο client</em>.</p>
<p>Στο παράδειγμά μας, όμως, θα χρησιμοποιήσουμε μια πιο ελαφρά βιβλιοθήκη, η οποία ταιριάζει καλύτερα στις απαιτήσεις αυτού του παραδείγματος. Αυτή είναι η βιβλιοθήκη <code>graphql-hooks</code>.</p>
<p>Τεκμηρίωση για αυτό το package υπάρχει στο <a href="https://github.com/nearform/graphql-hooks/blob/master/README.md#useManualQuery">github</a>.</p>
<p>Εγκαθιστούμε το πακέτο με την εντολή:
<code>npm install graphql-hooks</code></p>
<p>Βεβαίως μπορούμε να δουλέψουμε στο codesandbox, όπου αρκεί να προσθέσουμε την εξάρτηση αυτή από το σχετικό μενού.</p>
<p>Στην συνέχεια ορίζουμε ένα αντικείμενο GraphQLClient το οποίο θα συνδέσουμε στον GraphQL server:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> GraphQLClient({
  <span class="hljs-attr">url</span>: <span class="hljs-string">'https://countries.trevorblades.com/'</span>
})
</div></code></pre>
<p>Μετά ορίζουμε ένα αντικείμενο πάροχο περιβάλλοντος  <code>ClientContext.Provider</code> στον οποίο θα περάσουμε ως τιμή το αντικείμενο client. Ενθυλακώνουμε το δένδρο των στοιχείων της εφαρμογής μας με το ClientContext της GraphQL:</p>
<pre class="hljs"><code><div>&lt;ClientContext.Provider value={client}&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CountryProvider</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span> = <span class="hljs-string">"App"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">SelectCode</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">FetchCountry</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">CountryProvider</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/ClientContext.Provider&gt;
</span></div></code></pre>
<p>Η <em>κατάσταση</em> της εφαρμογής συντηρείται μέσα στο στοιχείο <code>&lt;CountryProvider&gt;</code>, όπως και στο παράδειγμα δημιουργίας πλαισίου κατάστασης που είδαμε σε προηγούμενη ενότητα.</p>
<p>Στο στοιχείο αυτό, η κατάσταση συντηρείται ως εξής:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [country, setCountry] = useState(<span class="hljs-string">""</span>); <span class="hljs-comment">// country code</span>
<span class="hljs-keyword">const</span> [data, setData] = useState({}); <span class="hljs-comment">// country data</span>
</div></code></pre>
<p>Τα δεδομένα κατάστασης ειναι:</p>
<ul>
<li><code>country</code> είναι ο κωδικός της χώρας, τα στοιχεία της οποίας αναζητούμε</li>
<li><code>data</code> είναι τα δεδομένα της χώρας τα οποία λαμβάνουμε από το σημείο επαφής graphQL.</li>
</ul>
<p>Το στοιχείο <code>&lt;SelectCode&gt;</code> περιέχει τη φόρμα μέσω της οποίας ο χρήστης εισάγει τον κωδικό δύο χαρακατήρων της χώρας.</p>
<p>Τέλος το στοιχείο <code>&lt;FetchCountry&gt;</code> είναι εκεί όπου χρησιμοποιείται το hook <code>useQuery</code> του πακέτου GraphQL-hook.</p>
<p>Για να ετοιμαστεί το ερώτημα, πρέπει να διαμορφώσουμε και στη συνέχεια να το εισάγουμε ως σταθερά.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> COUNTRY_DATA = <span class="hljs-string">`
query CountryData ($countryCode: ID!) {
	country(code:$countryCode){
    name
    capital
    emoji
    code
  }
}
</span></div></code></pre>
<p>Στη συνέχεια στο στοιχείο <code>&lt;FetchData /&gt;</code>, χρησιμοποιούμε το hook <code>useQuery</code> του πακέτου GraphQL-hook ως εξής:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { loading, error, data } = useQuery(COUNTRY_DATA, {
  <span class="hljs-attr">variables</span>: {
    <span class="hljs-attr">countryCode</span>: value.country
  }
})
</div></code></pre>
<p>Ο κωδικός της χώρας περνάει στο ερώτημα, μέσω της μεταβλητής κατάστασης value.</p>
<p>Το ειδικό αυτό hook που εισάγει το πακέτο, φροντίζει να διατυπώνει το ερώτημα, να εκτελεί την εντολή ανάκτησης δεδομένων και να αποθηκεύει τα αποτελέσματα στην ενδιάμεση μνήμη. Θα πρέπει να σημειωθεί ότι το ερώτημα δεν θα ξαναγίνει εκτός αν τροποποιηθεί το ερώτημα query ή αν μεταβληθεί η τιμή της μεταβλητής κατάστασης country, δηλαδή ο χρήστης έχει ζητήσει νέα δεδομένα.</p>
<h4 id="%CE%B4%CE%B5%CF%8D%CF%84%CE%B5%CF%81%CE%BF-%CF%80%CE%B1%CF%81%CE%AC%CE%B4%CE%B5%CE%B9%CE%B3%CE%BC%CE%B1-%CE%B5%CF%86%CE%B1%CF%81%CE%BC%CE%BF%CE%B3%CE%AE%CF%82-graphql">Δεύτερο παράδειγμα εφαρμογής graphQL</h4>
<p>Στην ενότητα αυτή συζητάμε ένα δεύτερο πιο προχωρημένο παράδειγμα, το οποίο χρησιμοποιεί το σημείο επαφής <a href="https://countries-274616.ew.r.appspot.com/">countires v.2 api</a>.</p>
<p>Στην εφαρμογή αυτή, ο χρήστης δίνει το όνομα μιας χώρας και στη συνέχεια εκτελείται μια αναζήτηση στο GraphQL API, στο οποίο ζητούνται τα εξής στοιχεία με βάση το ερώτημα του χρήστη: το όνομα της χώρας που ταιριάζει καλύτερα στο ερώτημα, τη διεύθυνση του αρχείου svg που αναπαριστά τη σημαία της χώρας, τα ονόματα και τα σύμβολα emoji που αναπαριστούν τις σημαίες των χωρών που συνορεύουν με τη χώρα αυτή.</p>
<p>Η ερώτηση αυτή διατυπώνεται ως ακολούθως στη γλώσσα ερωτήσεων της graphql:</p>
<pre class="hljs"><code><div>query {
	Country (name: &quot;Greece&quot;) {
    name
    flag { svgFile }
    borders {
      name
      flag { emoji }
    }
  }
}
</div></code></pre>
<div style="page-break-after: always"></div>
<h2 id="814-%CF%84%CE%BF-%CE%BF%CE%B9%CE%BA%CE%BF%CF%83%CF%8D%CF%83%CF%84%CE%B7%CE%BC%CE%B1-%CF%84%CE%B7%CF%82-react">8.14 Το οικοσύστημα της React</h2>
<p>Ολοκληρώνοντας την σύντομη εισαγωγή στη React, θα παραθέσουμε στην ενότητα αυτή πηγές για πρόσθετα στοιχεία που είναι διαθέσιμα και μπορούμε να χρησιμοποιήσουμε σε μια εφαρμογή React.</p>
<p>Ένα από τα κύρια πλεονεκτήματα της χρήσης της React είναι το οικοσύστημα βιβλιοθηκών έτοιμων στοιχείων και άλλων πρόσθετων modules που έχουν αναπτυχθεί για αυτό το Πλαίσιο, δεδομένης της υψηλής δημοτικότητάς του.</p>
<h5 id="%CE%BA%CF%8D%CF%81%CE%B9%CE%B1-%CF%83%CF%85%CF%83%CF%84%CE%B1%CF%84%CE%B9%CE%BA%CE%AC">Κύρια συστατικά</h5>
<p>Τα κύρια συστατικά στοιχεία του οικοσυστήματος αυτού είναι:</p>
<ul>
<li>
<p>Η βιβλιοθήκη <strong>React</strong> καθώς και η βιβλιοθήκη <strong>React-DOM</strong> για διαχείριση του DOM στοιχείων React.</p>
</li>
<li>
<p>H <strong>JSX</strong>, μια γλώσσα επισημείωσης που μάς επιτρέπει την εισαγωγή εντολών HTML στην JavaScript.</p>
</li>
<li>
<p>Η <strong>Create React App (create-react-app)</strong>, μια διεπαφή γραμμής εντολών που μάς επιτρέπει να δημιουργήσουμε γρήγορα ένα πρότζεκτ React.</p>
</li>
<li>
<p>Τα εργαλεία <strong>React Developer Tools</strong> για τους φυλλομετρητές Chrome και Firefox, τα οποία μάς επιτρέπουν να βλέπουμε γραφικά το React DOM και τις ιδιότητες και κατάσταση των στοιχείων του.</p>
</li>
<li>
<p>Επίσης το οικοσύστημα της React διαθέτει διαδικτυακά περιβάλλοντα πειραματισμού με την τεχνολογία αυτή, τα οποία μάς επιτρέπουν να αναπτύξουμε γρήγορα και να διαμοιράσουμε στη συνέχεια εφαρμογές, όπως τυπικό παράδειγμα είναι το <a href="https://codesandbox.io/">codesandbox</a> που χρησιμοποιήσαμε σε αυτή την ενότητα.</p>
</li>
</ul>
<p>Τα παραπάνω συστατικά στοιχεία του οικοσυστήματος της React τα έχουμε ήδη συναντήσει σε προηγούμενες ενότητες αυτών των μαθημάτων.</p>
<p>Θα δούμε στη συνέχεια κάποια ακόμη στοιχεία πολύ διαδεδομένα στον κόσμο της React, τα οποία μπορεί να χρειαστείτε όταν αναπτύσσετε εφαρμογές με την React.</p>
<h5 id="%CE%AC%CE%BB%CE%BB%CE%B1-%CF%83%CF%85%CF%83%CF%84%CE%B1%CF%84%CE%B9%CE%BA%CE%AC">Άλλα συστατικά</h5>
<ul>
<li>
<p>To <strong>Redux</strong> είναι ένα framework για διαχείριση των δεδομένων κατάστασης μιας εφαρμογής JavaScript, πιο προχωρημένο και σύνθετο από τη χρήση του hook Context που είδαμε εδώ. Συχνά το Redux χρησιμοποιείται σε εφαρμογές React, ιδιαίτερα αν οι απαιτήσεις τους για διαχείριση δεδομένων κατάστασης είναι αυξημένες.</p>
</li>
<li>
<p>Το <strong>React-router</strong> χρησιμοποιείται για δρομολόγηση της εφαρμογής μεταξύ πολλαπλών ιστοσελίδων, αν αυτό απαιτείται.</p>
</li>
<li>
<p>Το <strong>Axios</strong> είναι μια βιβλοθήκη για επικοινωνία με τον εξυπηρετητή, αν δεν θέλουμε να χρησιμοποιήσουμε απλά τη διεπαφή fetch.</p>
</li>
<li>
<p>H <strong>React Native</strong> είναι μια επέκταση της React για ανάπτυξη εφαρμογών σε κινητές συσκευές σε λειτουργικά συστήματα iOS και Android. Η ύπαρξή τας κάνει την React ελκυστική αφού αντικαθιστά τη συγγραφή κώδικα εγγενώς για τα περιβάλλοντα των λειτουργικών αυτών (συνήθως σε Java, Swift, kλπ.) με τη χρήση της JavaScript και της React.</p>
</li>
</ul>
<h5 id="%CE%B2%CE%B9%CE%B2%CE%BB%CE%B9%CE%BF%CE%B8%CE%AE%CE%BA%CE%B5%CF%82-%CF%83%CF%84%CE%BF%CE%B9%CF%87%CE%B5%CE%AF%CF%89%CE%BD-%CF%84%CE%B7%CF%82-react">Βιβλιοθήκες στοιχείων της React</h5>
<p>Όπως έχει γίνει αντιληπτό από την ως τώρα παρουσίαση, η React στηρίζεται στη δημιουργία Στοιχείων (Components) τα οποία εντάσσονται σε μια ιεραρχία. Το καθένα από αυτά ορίζεται σε ένα ξεχωριστό αρχείο και έχει γνωρίσματα και ιδιότητες που καθορίζουν τη λειτουργία του και εν μέρει την εμφάνισή του. Είναι συνεπώς εύκολο κάποιος να δημιουργήσει μια <strong>Βιβλιοθήκη από επαναχρησιμοποιήσιμα στοιχεία</strong>. Έχουν δημιουργηθεί αρκετές τέτοιες βιβλιοθήκες, κάποιες μάλιστα τις χρησιμοποιήσαμε σε κάποια παραδείγματά μας.</p>
<p>Παραδείγματα τέτοιων βιβλιοθηκών είναι:</p>
<ul>
<li>Η [material-ui](https://material-ui.com/ (που υλοποιεί τη σχεδίαση material design της Google),</li>
<li><a href="https://ant.design/docs/react/introduce">ant design</a>,</li>
<li><a href="https://storybook.js.org/">strorybook</a> (ένα εργαλείο ανοικτού κώδικα για ανάπτυξη στοιχείων χρήστη για όλα τα βασικά frameworks, μεταξύ των οποίων βεβαίως η React),</li>
<li>H <a href="https://react-bootstrap.github.io/">react bootstrap</a> (μια βιβλιοθήκη React library του δημοφιλούς αυτού front-end UI framewrok),</li>
<li><a href="https://bvaughn.github.io/react-virtualized/#/components/List">react virtualized</a> είναι βιβλιοθήκη κατάλληλη για παρουσίαση μεγάλου όγκου δεδομένων, όπως ήταν το στοιχείο FixedSizeList της react-window που είδαμε σε προηγούμενη ενότητα),</li>
<li><a href="https://react.semantic-ui.com/">semantic ui</a>,
κλπ.</li>
</ul>
<h5 id="%CF%80%CE%B7%CE%B3%CE%AD%CF%82">Πηγές</h5>
<ul>
<li>Boduch, Adam, React and React Native, 3rd Edition, Packt Publishing, 2020. <a href="https://www.packtpub.com/product/react-and-react-native-third-edition/9781839211140">πληροφορίες</a></li>
<li>Banks Alex, Procello Eve, Learning React: Modern Patterns for Developing React Apps 2nd Edition, 2020, O'Reilly publ. <a href="https://www.oreilly.com/library/view/learning-react-2nd/9781492051718/">πληροφορίες</a></li>
<li>Scott Adam, JavaScript Everywhere, Building Cross-Platform Applications with GraphQL, React, React Native, and Electron, 2020, O'Reilly publ. <a href="https://www.oreilly.com/library/view/javascript-everywhere/9781492046974/">πληροφορίες</a></li>
</ul>
<p>Διαδικτυακές πηγές</p>
<ul>
<li><a href="https://reactjs.org/tutorial/tutorial.html">Εισαγωγικό μάθημα στη React από τη σελίδα reactjs.org</a></li>
</ul>

</body>
</html>
